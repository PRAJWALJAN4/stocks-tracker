<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stock Portfolio MTF Tracker</title>
  <style>
    :root {
      --color-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --color-surface: #ffffff;
      --color-primary: #667eea;
      --color-primary-hover: #5568d3;
      --color-accent: #764ba2;
      --color-text: #2d3748;
      --color-text-light: #718096;
      --color-border: #e2e8f0;
      --color-danger: #f56565;
      --color-success: #48bb78;
      --color-warning: #ed8936;
      --color-info: #4299e1;
      --color-focus-ring: rgba(102, 126, 234, 0.4);
      --color-secondary: rgba(237, 242, 247, 1);
      --color-card-bg: #f7fafc;
      --radius: 12px;
      --shadow: 0 4px 6px rgba(0,0,0,0.07);
      --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
      --font-normal: 400;
      --font-medium: 500;
      --font-bold: 600;
      font-family: "Inter", -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;
    }
    html, body {
      height: 100%;
      background: var(--color-bg);
      margin: 0;
      padding: clamp(12px, 2vw, 32px);
      box-sizing: border-box;
      font-family: inherit;
      color: var(--color-text);
      overflow-x: hidden;
    }
    .container {
      max-width: min(1100px, calc(100vw - 32px));
      margin: 24px auto;
      background: var(--color-surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow-lg);
      padding: clamp(24px, 4vw, 48px);
      border: none;
    }
    h1, h2 {
      margin-bottom: 8px;
      font-weight: var(--font-bold);
      letter-spacing: -0.01em;
      background: linear-gradient(135deg, var(--color-primary), var(--color-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .subtitle {
      color: var(--color-text-light);
      font-size: 15px;
      margin-bottom: 24px;
    }
    .form-row {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      margin-bottom: 18px;
      align-items: flex-end;
    }
    .form-group {
      display: flex;
      flex-direction: column;
      flex: 1 1 130px;
      min-width: 110px;
    }
    .form-group label {
      font-size: 13px;
      font-weight: var(--font-medium);
      margin-bottom: 5px;
    }
    .form-group input, .form-group select {
      padding: 10px 14px;
      border-radius: 8px;
      border: 2px solid var(--color-border);
      font-size: 15px;
      font-family: inherit;
      background: white;
      color: var(--color-text);
      box-sizing: border-box;
      transition: all 0.2s ease;
    }
    .form-group input:focus, .form-group select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px var(--color-focus-ring);
    }
    .autocomplete-dropdown {
      position: absolute;
      background: white;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      max-height: 240px;
      overflow-y: auto;
      z-index: 1000;
      width: 100%;
      margin-top: 4px;
      box-shadow: var(--shadow-lg);
    }
    .autocomplete-item {
      padding: 12px 14px;
      cursor: pointer;
      border-bottom: 1px solid var(--color-border);
      transition: background 0.15s;
    }
    .autocomplete-item:hover {
      background: var(--color-secondary);
    }
    .autocomplete-item strong {
      color: var(--color-primary);
      font-weight: 600;
    }
    .autocomplete-item small {
      color: var(--color-text-light);
      display: block;
      font-size: 13px;
      margin-top: 2px;
    }
    .mtf-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      color: var(--color-text-light);
      margin-top: 6px;
    }
    .mtf-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    .btn {
      background: linear-gradient(135deg, var(--color-primary), var(--color-accent));
      color: #fff;
      border: none;
      padding: 12px 28px;
      font-size: 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: var(--font-bold);
      transition: all 0.3s ease;
      margin-left: 8px;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    .btn:active, .btn:focus {
      transform: translateY(0);
      background: linear-gradient(135deg, var(--color-primary-hover), var(--color-accent));
    }
    #portfolioWrap {
      overflow-x: auto;
    }
    .portfolio-table {
      margin-top: 32px;
      min-width: 960px;
      width: 100%;
      border-collapse: collapse;
      background-color: var(--color-surface);
      box-shadow: var(--shadow-lg);
      border-radius: var(--radius);
      overflow: hidden;
    }
    .portfolio-table th, .portfolio-table td {
      padding: 14px 16px;
      border-bottom: 1px solid var(--color-border);
      text-align: center;
      font-size: 14px;
    }
    .portfolio-table thead th {
      background: linear-gradient(135deg, var(--color-primary), var(--color-accent));
      color: white;
      font-weight: var(--font-bold);
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 0.5px;
    }
    .portfolio-table tbody tr {
      transition: background 0.2s ease;
    }
    .portfolio-table tbody tr:hover {
      background: var(--color-card-bg);
    }
    .status-profit { 
      color: var(--color-success); 
      font-weight: 600;
      background: rgba(72, 187, 120, 0.1);
      padding: 4px 12px;
      border-radius: 16px;
      display: inline-block;
    }
    .status-loss { 
      color: var(--color-danger); 
      font-weight: 600;
      background: rgba(245, 101, 101, 0.1);
      padding: 4px 12px;
      border-radius: 16px;
      display: inline-block;
    }
    .status-neutral { 
      color: var(--color-warning); 
      font-weight: 600;
      background: rgba(237, 137, 54, 0.1);
      padding: 4px 12px;
      border-radius: 16px;
      display: inline-block;
    }
    .delete-btn {
      background: var(--color-danger);
      color: #fff;
      border: none;
      border-radius: var(--radius);
      padding: 5px 14px;
      cursor: pointer;
      font-size: 14px;
    }
    .flex {
      display: flex;
      flex-wrap: wrap;
      align-items: stretch;
      gap: 20px;
      margin-top: 32px;
      justify-content: space-between;
    }
    .summary-card {
      flex: 1;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 2px solid var(--color-border);
      padding: 24px;
      min-width: 210px;
      text-align: center;
      transition: all 0.3s ease;
    }
    .summary-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
      border-color: var(--color-primary);
    }
    .summary-title { 
      font-size: 13px; 
      color: var(--color-text-light);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    .summary-value { 
      font-size: 28px; 
      font-weight: 700;
      margin: 8px 0;
      background: linear-gradient(135deg, var(--color-primary), var(--color-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .summary-detail { font-size: 13px; color: var(--color-text-light); }
    .insights-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
      margin-top: 24px;
    }
    .insight-card {
      background: rgba(255,255,255,0.9);
      border-radius: var(--radius);
      border: 2px solid var(--color-border);
      padding: 20px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .insight-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      color: var(--color-text-light);
      font-weight: 600;
    }
    .insight-value {
      font-size: 22px;
      font-weight: 700;
      color: var(--color-primary);
    }
    .insight-meta {
      font-size: 13px;
      color: var(--color-text-light);
    }
    @media (max-width: 800px) {
      .container { padding: 10px;}
      .flex { flex-direction: column; gap: 10px;}
      .portfolio-table th, .portfolio-table td { font-size: 13px;}
    }
    .chart-grid {
      margin-top: 32px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 24px;
    }
    .chart-card {
      background: rgba(255,255,255,0.95);
      border-radius: var(--radius);
      padding: 20px;
      border: 2px solid var(--color-border);
      box-shadow: var(--shadow);
    }
    .chart-card h3 {
      margin: 0 0 12px;
      font-size: 16px;
      color: var(--color-primary);
    }
    .csv-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 16px 0 8px;
      align-items: center;
    }
    .csv-actions button, .csv-actions label {
      background: rgba(102, 126, 234, 0.12);
      border: 2px dashed var(--color-primary);
      color: var(--color-primary);
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }
    .csv-actions label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .csv-actions button:hover, .csv-actions label:hover {
      background: rgba(102, 126, 234, 0.2);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.5/dist/chart.umd.min.js"></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
</head>
<body>
  <!-- Device Registration Screen -->
  <div id="deviceScreen" class="container" style="max-width: 420px; margin-top: 80px; padding: 48px; display: none;">
    <div id="deviceBackButton" style="margin-bottom: 16px; display: none;">
      <button onclick="backToApp()" style="background: transparent; border: 1px solid var(--color-border); color: var(--color-text); padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 14px;">‚Üê Back</button>
    </div>
    <div style="text-align: center; margin-bottom: 32px;">
      <div style="width: 80px; height: 80px; background: linear-gradient(135deg, var(--color-primary), var(--color-accent)); border-radius: 50%; margin: 0 auto 24px; display: flex; align-items: center; justify-content: center; font-size: 36px;">üì±</div>
      <h1 style="font-size: 28px; margin-bottom: 8px;">Device Management</h1>
      <p class="subtitle" style="margin: 0;">Optional: Track your registered devices (for information only)</p>
    </div>
    
    <div style="background: rgba(66, 153, 225, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--color-info);">
      <p style="margin: 0; font-size: 13px; color: var(--color-text);">
        <strong>‚ÑπÔ∏è Note:</strong> Device registration is optional. You can access your portfolio on any device by logging in with your account. This is just for tracking purposes.
      </p>
    </div>
    
    <div style="margin-bottom: 24px;">
      <div class="form-group" style="margin-bottom: 0;">
        <label for="deviceName">Device Name (Optional)</label>
        <input type="text" id="deviceName" placeholder="e.g., My Laptop, Phone, Tablet" style="width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--color-border); border-radius: 8px;">
      </div>
    </div>
    
    <div style="margin-bottom: 24px;">
      <button class="btn" onclick="handleDeviceRegistration()" style="width: 100%; padding: 14px; font-size: 16px; margin: 0;">Register This Device</button>
    </div>
    
    <div id="deviceError" style="color: var(--color-danger); margin-top: 20px; text-align: center; font-size: 14px; padding: 12px; background: rgba(245, 101, 101, 0.1); border-radius: 8px; display: none;"></div>
    
    <div id="deviceList" style="margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--color-border);">
      <p style="font-size: 13px; color: var(--color-text-light); margin-bottom: 12px; text-align: center;">Registered Devices (<span id="deviceCount">0</span>/3)</p>
      <div id="deviceListItems" style="max-height: 200px; overflow-y: auto;"></div>
    </div>
    
    <p style="text-align: center; margin-top: 32px; font-size: 13px; color: var(--color-text-light);">
      ‚ö†Ô∏è Maximum 3 devices allowed. Remove old devices to add new ones.
    </p>
  </div>

  <!-- Login Screen -->
  <div id="loginScreen" class="container" style="max-width: 420px; margin-top: 80px; padding: 48px; display: none;">
    <div style="text-align: center; margin-bottom: 32px;">
      <div style="width: 80px; height: 80px; background: linear-gradient(135deg, var(--color-primary), var(--color-accent)); border-radius: 50%; margin: 0 auto 24px; display: flex; align-items: center; justify-content: center; font-size: 36px;">üìä</div>
      <h1 style="font-size: 28px; margin-bottom: 8px;">Stock Portfolio Tracker</h1>
      <p class="subtitle" style="margin: 0;">Sign in to continue to your portfolio</p>
    </div>
    
    <div style="margin-bottom: 16px;">
      <div class="form-group" style="margin-bottom: 0;">
        <input type="text" id="loginUsername" placeholder="Enter your username" style="width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--color-border); border-radius: 8px;" autocomplete="username">
      </div>
    </div>
    
    <div style="margin-bottom: 24px;">
      <div class="form-group" style="margin-bottom: 0;">
        <input type="password" id="loginPassword" placeholder="Enter your password" style="width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--color-border); border-radius: 8px;" autocomplete="current-password">
      </div>
    </div>
    
    <div style="margin-bottom: 24px;">
      <button id="loginButton" class="btn" onclick="handleLogin()" style="width: 100%; padding: 14px; font-size: 16px; margin: 0;">Sign in</button>
    </div>
    
    <div style="text-align: center; margin: 24px 0; position: relative;">
      <span style="background: var(--color-surface); padding: 0 16px; position: relative; z-index: 1; color: var(--color-text-light); font-size: 14px;">or</span>
      <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: var(--color-border); z-index: 0;"></div>
    </div>
    
    <div>
      <button class="btn" onclick="showSignupForm()" style="width: 100%; background: white; color: var(--color-primary); border: 2px solid var(--color-border); padding: 14px; font-size: 16px; margin: 0; box-shadow: none;">Create account</button>
    </div>
    
    <div id="loginError" style="color: var(--color-danger); margin-top: 20px; text-align: center; font-size: 14px; padding: 12px; background: rgba(245, 101, 101, 0.1); border-radius: 8px; display: none;"></div>
    
    <p style="text-align: center; margin-top: 32px; font-size: 13px; color: var(--color-text-light);">
      üîí Your data is stored securely and locally in your browser
    </p>
  </div>

  <!-- Signup Screen -->
  <div id="signupScreen" class="container" style="max-width: 420px; margin-top: 80px; padding: 48px; display: none;">
    <div style="text-align: center; margin-bottom: 32px;">
      <div style="width: 80px; height: 80px; background: linear-gradient(135deg, var(--color-primary), var(--color-accent)); border-radius: 50%; margin: 0 auto 24px; display: flex; align-items: center; justify-content: center; font-size: 36px;">üìä</div>
      <h1 style="font-size: 28px; margin-bottom: 8px;">Create Account</h1>
      <p class="subtitle" style="margin: 0;">Start tracking your stock portfolio</p>
    </div>
    
    <div style="margin-bottom: 16px;">
      <div class="form-group" style="margin-bottom: 0;">
        <input type="text" id="signupUsername" placeholder="Choose a username" style="width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--color-border); border-radius: 8px;" autocomplete="username">
      </div>
    </div>
    
    <div style="margin-bottom: 16px;">
      <div class="form-group" style="margin-bottom: 0;">
        <input type="password" id="signupPassword" placeholder="Create a password" style="width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--color-border); border-radius: 8px;" autocomplete="new-password">
      </div>
    </div>
    
    <div style="margin-bottom: 24px;">
      <div class="form-group" style="margin-bottom: 0;">
        <input type="password" id="signupPasswordConfirm" placeholder="Confirm password" style="width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--color-border); border-radius: 8px;" autocomplete="new-password">
      </div>
    </div>
    
    <div style="margin-bottom: 24px;">
      <button class="btn" onclick="handleSignup()" style="width: 100%; padding: 14px; font-size: 16px; margin: 0;">Create Account</button>
    </div>
    
    <div style="text-align: center;">
      <button onclick="showLoginForm()" style="background: transparent; border: none; color: var(--color-primary); cursor: pointer; font-size: 14px; text-decoration: underline;">Already have an account? Sign in</button>
    </div>
    
    <div id="signupError" style="color: var(--color-danger); margin-top: 20px; text-align: center; font-size: 14px; padding: 12px; background: rgba(245, 101, 101, 0.1); border-radius: 8px; display: none;"></div>
    
    <div id="passwordStrength" style="margin-top: 16px; padding: 8px 12px; border-radius: 8px; font-size: 13px; display: none;"></div>
  </div>

  <!-- Main App (hidden initially) -->
  <div id="mainApp" class="container" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <h1>üìä Stock Portfolio MTF Tracker</h1>
      <div style="display: flex; align-items: center; gap: 16px;">
        <span style="color: var(--color-primary); font-weight: 600;">üë§ <span id="displayUsername"></span></span>
        <button onclick="showDeviceManagement()" style="background: rgba(102, 126, 234, 0.1); color: var(--color-primary); border: 2px solid var(--color-primary); padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px;">üîí Devices</button>
        <button onclick="handleLogout()" style="background: var(--color-danger); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">Logout</button>
      </div>
    </div>
    <p class="subtitle">
      Track your leveraged stock positions with live price updates ‚Ä¢ Broker: <b>Pocketfull</b> ‚Ä¢ MTF supported
    </p>
    <div id="cloudSyncNotification" style="display: none; background: linear-gradient(135deg, rgba(66, 153, 225, 0.1), rgba(102, 126, 234, 0.1)); border: 2px solid var(--color-info); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
      <div style="display: flex; justify-content: space-between; align-items: start; gap: 16px;">
        <div style="flex: 1;">
          <div style="font-weight: 600; color: var(--color-info); margin-bottom: 8px; font-size: 15px;">‚òÅÔ∏è Enable Cloud Sync for Multi-Device Access</div>
          <div style="font-size: 13px; color: var(--color-text); line-height: 1.5;">
            To access your portfolio from multiple devices, choose a sync method:<br>
            <strong>Cloud (GitHub):</strong> Free, requires GitHub token<br>
            <strong>Google Drive:</strong> Use your existing Google account - Click "üìÅ Upload to Drive" to start
          </div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button onclick="showCloudSettings()" class="btn" style="padding: 8px 16px; font-size: 14px; margin: 0;">‚öôÔ∏è Setup Cloud Sync</button>
          <button onclick="document.getElementById('cloudSyncNotification').style.display='none'; localStorage.setItem('stockapp_cloud_sync_notification_dismissed', 'true');" style="background: transparent; border: none; color: var(--color-text-light); cursor: pointer; font-size: 20px; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;">√ó</button>
        </div>
      </div>
    </div>
    <form id="addForm">
      <div class="csv-actions" style="margin-bottom: 12px;">
        <button type="button" id="downloadCsvBtn">‚¨á Download CSV</button>
        <label for="uploadCsvInput">‚¨Ü Upload CSV</label>
        <input type="file" id="uploadCsvInput" accept=".csv" style="display:none;">
        <button type="button" id="syncToCloudBtn" title="Upload data to cloud (syncs across devices)">‚òÅÔ∏è Upload to Cloud</button>
        <button type="button" id="syncFromCloudBtn" title="Download data from cloud">‚¨á Download from Cloud</button>
        <button type="button" id="syncToDriveBtn" title="Upload data to Google Drive">üìÅ Upload to Drive</button>
        <button type="button" id="syncFromDriveBtn" title="Download data from Google Drive">‚¨á Download from Drive</button>
        <button type="button" id="cloudSettingsBtn" title="Configure cloud sync">‚öôÔ∏è Cloud Settings</button>
        <span style="font-size:13px;color:var(--color-text-light);">Backup, import, or sync your portfolio data across devices via Cloud or Google Drive.</span>
      </div>
      <div class="form-row">
        <div class="form-group" style="position: relative;">
          <label for="companySearch">Search Company Name</label>
          <input type="text" id="companySearch" placeholder="Type company name..." autocomplete="off">
          <div id="autocompleteDropdown" class="autocomplete-dropdown" style="display:none;"></div>
          <small id="searchStatus" style="color:var(--color-text-light);font-size:12px;display:block;margin-top:4px;">Type at least 2 characters to search NSE listings.</small>
        </div>
        <div class="form-group">
          <label for="symbol">Stock Symbol (NSE)</label>
          <input type="text" id="symbol" placeholder="Type or auto-filled" style="background:#f7fafc;">
        </div>
        <div class="form-group">
          <label for="company">Company Name</label>
          <input type="text" id="company" placeholder="Auto-filled" readonly style="background:#f7fafc;">
        </div>
        <div class="form-group">
          <label for="broker">Broker</label>
          <select id="broker" required></select>
          <small style="color:var(--color-text-light);font-size:12px;">Pocketfull by default. Pick another broker if needed.</small>
        </div>
        <div class="form-group">
          <label for="entryDate">Entry Date</label>
          <input type="date" id="entryDate" required>
        </div>
        <div class="form-group">
          <label for="entryPrice">Entry Price</label>
          <input type="number" step="0.01" min="0" id="entryPrice" required>
        </div>
        <div class="form-group">
          <label for="quantity">Quantity</label>
          <input type="number" step="1" min="1" id="quantity" required>
        </div>
        <div class="form-group">
          <label for="ownCapital">Own Capital Used (‚Çπ)</label>
          <input type="number" min="1" id="ownCapital" required>
        </div>
        <div class="form-group">
          <label for="mtfFunds">MTF Funds Used (‚Çπ)</label>
          <input type="number" min="0" id="mtfFunds" value="0" required>
          <label class="mtf-toggle"><input type="checkbox" id="mtfEnabled" checked> Using MTF for this trade</label>
          <small style="color:var(--color-text-light);font-size:12px;">Interest auto-calculates from broker rules.</small>
        </div>
        <div class="form-group">
          <label for="interest">Daily Interest Rate (%)</label>
          <input type="number" step="0.001" id="interest" placeholder="Default: 0.035" value="0.035" required>
        </div>
        <button class="btn" type="submit">Add Stock</button>
      </div>
    </form>
    <div id="errorMsg" style="color:var(--color-danger);margin-bottom:10px;"></div>
    <div id="portfolioWrap">
      <table class="portfolio-table" id="portfolioTable">
        <thead>
          <tr>
            <th>Stock</th>
            <th>Company</th>
            <th>Broker</th>
            <th>Entry Date</th>
            <th>Entry Price</th>
            <th>Qty</th>
            <th>Own Capital (‚Çπ)</th>
            <th>MTF (‚Çπ)</th>
            <th>Total Investment (‚Çπ)</th>
            <th>Leverage (x)</th>
            <th>Current Price</th>
            <th>Current Value (‚Çπ)</th>
            <th>Total P/L (‚Çπ)</th>
            <th>P/L %</th>
            <th>Days Held</th>
            <th>Total Interest (‚Çπ)</th>
            <th>Net P/L (‚Çπ)</th>
            <th>Net ROI (%)</th>
            <th>Status</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="portfolioBody">
        </tbody>
      </table>
    </div>
    <div class="flex" id="summaryWrap">
      <!-- Summary cards injected here -->
    </div>
    <div id="insightsWrap" class="insights-grid"></div>
    <div class="chart-grid">
      <div class="chart-card">
        <h3>Allocation by Stock</h3>
        <canvas id="chartAllocation" height="220"></canvas>
      </div>
      <div class="chart-card">
        <h3>Net P/L by Stock</h3>
        <canvas id="chartProfit" height="220"></canvas>
      </div>
      <div class="chart-card">
        <h3>Broker MTF Exposure</h3>
        <canvas id="chartBroker" height="220"></canvas>
      </div>
    </div>
    <p style="margin-top:32px;font-size:14px;color:var(--color-primary);">
      * Live prices fetched from NSE using a public market API (for demo;<br>production: <b>add your Pocketfull API credentials in JS</b>).
      <br>* All calculations update automatically as prices change.
    </p>
  </div>

  <!-- Cloud Sync Settings Modal -->
  <div id="cloudSettingsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div class="container" style="max-width: 500px; margin: auto; position: relative; top: 50%; transform: translateY(-50%);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
        <h2 style="margin: 0;">‚òÅÔ∏è Cloud Sync Settings</h2>
        <button onclick="closeCloudSettings()" style="background: var(--color-danger); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">‚úñ Close</button>
      </div>
      <div style="background: rgba(245, 101, 101, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--color-danger);">
        <p style="margin: 0; font-size: 13px; color: var(--color-text);">
          <strong>‚ö†Ô∏è Security Note:</strong> Your GitHub token is stored locally in your browser. Never share it publicly.
        </p>
      </div>
      <div class="form-group" style="margin-bottom: 16px;">
        <label for="githubToken">GitHub Personal Access Token</label>
        <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid var(--color-border); border-radius: 8px; font-family: monospace;">
        <small style="color: var(--color-text-light); font-size: 12px; display: block; margin-top: 6px;">
          Create one at: <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--color-primary);">github.com/settings/tokens</a><br>
          Required scopes: <code>gist</code> (to create/update gists)
        </small>
      </div>
      <div class="form-group" style="margin-bottom: 16px;">
        <label for="gistId">Gist ID (Optional - auto-created if empty)</label>
        <input type="text" id="gistId" placeholder="Leave empty to auto-create" style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid var(--color-border); border-radius: 8px; font-family: monospace;">
        <small style="color: var(--color-text-light); font-size: 12px; display: block; margin-top: 6px;">
          If you already have a Gist ID from another device, enter it here to sync to the same location.
        </small>
      </div>
      <div style="display: flex; gap: 12px;">
        <button onclick="saveCloudSettingsFromModal()" class="btn" style="flex: 1; margin: 0;">üíæ Save Settings</button>
        <button onclick="testCloudConnection()" class="btn" style="flex: 1; margin: 0; background: rgba(102, 126, 234, 0.1); color: var(--color-primary); border: 2px solid var(--color-primary);">üîç Test Connection</button>
      </div>
      <div id="cloudStatus" style="margin-top: 16px; padding: 12px; border-radius: 8px; display: none;"></div>
    </div>
  </div>

<script>
  // ====== CONFIGURATION =======
  // By default uses a public NSE API. To connect your own Pocketfull API,
  // replace fetchNSEPrice() implementation with proper Pocketfull REST API.

  // Broker catalog with indicative daily MTF rates (%)
  const brokerCatalog = [
    {
      id: 'POCKETFULL',
      name: 'Pocketfull',
      rateStrategy: {
        type: 'tiered_per_lakh',
        tiers: [
          { max: 100000, perDayPerLakh: 16.4 },
          { max: 2500000, perDayPerLakh: 40 },
          { max: Infinity, perDayPerLakh: 43.8 }
        ]
      }
    },
    { id: 'ZERODHA', name: 'Zerodha', rateStrategy: { type: 'flat_percent', percentPerDay: 0.04 } },
    { id: 'UPSTOX', name: 'Upstox', rateStrategy: { type: 'flat_percent', percentPerDay: 0.05 } }, // ‚Çπ20 per ‚Çπ40k -> 0.05%
    { id: 'ANGELONE', name: 'Angel One', rateStrategy: { type: 'flat_percent', percentPerDay: 0.039 } },
    { id: 'ICICIDIRECT', name: 'ICICI Direct', rateStrategy: { type: 'flat_percent', percentPerDay: 0.042 } },
    { id: 'HDFCSEC', name: 'HDFC Securities', rateStrategy: { type: 'flat_percent', percentPerDay: 0.041 } },
    { id: 'KOTAK', name: 'Kotak Securities', rateStrategy: { type: 'flat_percent', percentPerDay: 0.041 } },
    { id: 'MOTILAL', name: 'Motilal Oswal', rateStrategy: { type: 'flat_percent', percentPerDay: 0.043 } },
    { id: 'SHAREKHAN', name: 'Sharekhan', rateStrategy: { type: 'flat_percent', percentPerDay: 0.04 } },
    {
      id: 'GROWW',
      name: 'Groww',
      rateStrategy: {
        type: 'annual_tiered_percent',
        tiers: [
          { max: 2500000, annualPercent: 15.75 },
          { max: Infinity, annualPercent: 9.75 }
        ]
      }
    }
  ];

  function getBrokerInfo(id) {
    return brokerCatalog.find(b => b.id === id) || brokerCatalog[0];
  }

  function getBrokerDisplayName(id) {
    const info = getBrokerInfo(id);
    if (info) return info.name;
    return id || 'Pocketfull';
  }

  function calculateBrokerDailyPercent(brokerId, mtfAmount = 0) {
    const info = getBrokerInfo(brokerId);
    if (!info) return 0.035;
    const strategy = info.rateStrategy || { type: 'flat_percent', percentPerDay: info.rate || 0.035 };
    const amount = Number(mtfAmount) || 0;
    
    const resolveTier = (tiers) => {
      if (!Array.isArray(tiers) || tiers.length === 0) return null;
      return tiers.find(tier => amount <= tier.max) || tiers[tiers.length - 1];
    };
    
    switch (strategy.type) {
      case 'tiered_per_lakh': {
        const tier = resolveTier(strategy.tiers);
        const perDayPerLakh = tier?.perDayPerLakh ?? 35;
        return (perDayPerLakh / 100000) * 100;
      }
      case 'annual_tiered_percent': {
        const tier = resolveTier(strategy.tiers);
        const annualPercent = tier?.annualPercent ?? 13;
        return annualPercent / 365;
      }
      case 'flat_percent':
      default: {
        return strategy.percentPerDay ?? strategy.rate ?? 0.035;
      }
    }
  }

  function escapeCsvValue(value) {
    if (value == null) return '';
    const str = String(value).replace(/"/g, '""');
    return /[",\n]/.test(str) ? `"${str}"` : str;
  }

  function buildCsvRow(stock) {
    return CSV_HEADERS.map(key => {
      if (key === 'isMTF') return escapeCsvValue(stock.isMTF ? 'true' : 'false');
      return escapeCsvValue(stock[key]);
    }).join(',');
  }

  function splitCsvLine(line) {
    const result = [];
    let current = '';
    let insideQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        if (insideQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          insideQuotes = !insideQuotes;
        }
      } else if (char === ',' && !insideQuotes) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current);
    return result;
  }

  function normalizeImportedRow(row) {
    const today = todayISO();
    const symbol = (row.symbol || '').trim().toUpperCase();
    const company = (row.company || '').trim();
    if (!symbol || !company) return null;
    const broker = row.broker || 'POCKETFULL';
    const entryDate = row.entryDate || today;
    const entryPrice = parseFloat(row.entryPrice) || 0;
    const quantity = parseInt(row.quantity, 10) || 0;
    const ownCapital = parseFloat(row.ownCapital) || 0;
    const mtfFunds = parseFloat(row.mtfFunds) || 0;
    const isMTF = String(row.isMTF).toLowerCase() === 'true' || mtfFunds > 0;
    const interest = isMTF ? (parseFloat(row.interest) || calculateBrokerDailyPercent(broker, mtfFunds)) : 0;
    const totalInvestment = entryPrice * quantity;
    const currentPrice = entryPrice;
    const currentValue = currentPrice * quantity;
    const totalPL = currentValue - totalInvestment;
    const plPc = totalInvestment > 0 ? (100 * totalPL / totalInvestment) : 0;
    const daysHeld = Math.max(1, Math.ceil((new Date(todayISO()) - new Date(entryDate)) / 86400000));
    const totalInterest = (mtfFunds * interest * daysHeld) / 100;
    const netPL = totalPL - totalInterest;
    const netROI = ownCapital > 0 ? (100 * netPL / ownCapital) : 0;
    const status = netPL > 0 ? 'Profit' : (netPL < 0 ? 'Loss' : 'Neutral');
    return {
      symbol,
      company,
      broker,
      isMTF,
      entryDate,
      entryPrice,
      quantity,
      ownCapital,
      mtfFunds,
      interest,
      totalInvestment,
      leverage: ownCapital > 0 ? totalInvestment / ownCapital : 0,
      currentPrice,
      currentValue,
      totalPL,
      plPc,
      daysHeld,
      totalInterest,
      netPL,
      netROI,
      status
    };
  }

  function handleDownloadCSV() {
    if (!portfolio.length) {
      alert('No portfolio data to export.');
      return;
    }
    const rows = [CSV_HEADERS.join(',')].concat(portfolio.map(buildCsvRow));
    const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `portfolio-${todayISO()}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  function setSearchStatus(message, tone = 'info') {
    if (!searchStatus) return;
    const colors = {
      info: 'var(--color-text-light)',
      success: 'var(--color-success)',
      warning: 'var(--color-warning)',
      error: 'var(--color-danger)'
    };
    searchStatus.style.color = colors[tone] || colors.info;
    searchStatus.innerText = message;
  }

  function dedupeSuggestions(list) {
    const seen = new Set();
    const result = [];
    for (const item of list) {
      const symbol = (item.symbol || '').toUpperCase();
      if (!symbol || seen.has(symbol)) continue;
      seen.add(symbol);
      result.push({
        symbol,
        name: item.name || symbol
      });
    }
    return result;
  }

  async function handleUploadCSVFile(file) {
    if (!file) return;
    try {
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(line => line.trim().length > 0);
      if (lines.length < 2) {
        alert('CSV file is empty or missing rows.');
        return;
      }
      const headers = splitCsvLine(lines[0]).map(h => h.trim());
      const imported = [];
      for (let i = 1; i < lines.length; i++) {
        const values = splitCsvLine(lines[i]);
        const row = {};
        headers.forEach((header, idx) => {
          row[header] = values[idx] || '';
        });
        const record = normalizeImportedRow(row);
        if (record) imported.push(record);
      }
      if (!imported.length) {
        alert('No valid rows found in CSV.');
        return;
      }
      imported.forEach(stock => portfolio.push(stock));
      saveUserData();
      renderPortfolio();
      alert(`Imported ${imported.length} positions successfully.`);
    } catch (error) {
      console.error('CSV import failed:', error);
      alert('Failed to import CSV. Please check the file format.');
    } finally {
      uploadCsvInput.value = '';
    }
  }

  function parseCSV(text, delimiter = ',') {
    const rows = [];
    let current = '';
    let row = [];
    let insideQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char === '"') {
        if (insideQuotes && text[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          insideQuotes = !insideQuotes;
        }
      } else if (char === delimiter && !insideQuotes) {
        row.push(current.trim());
        current = '';
      } else if ((char === '\n' || char === '\r') && !insideQuotes) {
        if (current || row.length) {
          row.push(current.trim());
          rows.push(row);
        }
        current = '';
        row = [];
        if (char === '\r' && text[i + 1] === '\n') i++;
      } else {
        current += char;
      }
    }
    if (current || row.length) {
      row.push(current.trim());
      rows.push(row);
    }
    return rows;
  }

  // ====== CLOUD SYNC (GitHub Gists) ======
  const CLOUD_STORAGE_KEY_PREFIX = 'stockapp_cloud_settings_';
  const CLOUD_GIST_FILENAME = 'portfolio-data.json';

  function getCloudSettings() {
    // Get cloud settings for current user (per-account)
    const userKey = currentUser ? `${CLOUD_STORAGE_KEY_PREFIX}${currentUser}` : CLOUD_STORAGE_KEY_PREFIX + 'global';
    const saved = localStorage.getItem(userKey);
    return saved ? JSON.parse(saved) : { token: '', gistId: '' };
  }

  function saveCloudSettings(settings) {
    // Save cloud settings for current user (per-account)
    const userKey = currentUser ? `${CLOUD_STORAGE_KEY_PREFIX}${currentUser}` : CLOUD_STORAGE_KEY_PREFIX + 'global';
    localStorage.setItem(userKey, JSON.stringify(settings));
  }

  function showCloudSettings() {
    const settings = getCloudSettings();
    document.getElementById('githubToken').value = settings.token || '';
    document.getElementById('gistId').value = settings.gistId || '';
    document.getElementById('cloudSettingsModal').style.display = 'flex';
    document.getElementById('cloudStatus').style.display = 'none';
  }
  window.showCloudSettings = showCloudSettings;

  function closeCloudSettings() {
    document.getElementById('cloudSettingsModal').style.display = 'none';
  }
  window.closeCloudSettings = closeCloudSettings;

  function saveCloudSettingsFromModal() {
    const token = document.getElementById('githubToken').value.trim();
    const gistId = document.getElementById('gistId').value.trim();
    
    if (!token) {
      showCloudStatus('‚ö†Ô∏è Please enter a GitHub token', 'warning');
      return;
    }
    
    saveCloudSettings({ token, gistId });
    showCloudStatus('‚úÖ Settings saved!', 'success');
    // Hide notification if cloud sync is now configured
    if (token && gistId) {
      const notification = document.getElementById('cloudSyncNotification');
      if (notification) notification.style.display = 'none';
    }
    setTimeout(() => {
      closeCloudSettings();
    }, 1000);
  }
  window.saveCloudSettingsFromModal = saveCloudSettingsFromModal;

  function showCloudStatus(message, type = 'info') {
    const statusElem = document.getElementById('cloudStatus');
    const colors = {
      success: { bg: 'rgba(72, 187, 120, 0.1)', border: 'var(--color-success)', text: 'var(--color-success)' },
      error: { bg: 'rgba(245, 101, 101, 0.1)', border: 'var(--color-danger)', text: 'var(--color-danger)' },
      warning: { bg: 'rgba(237, 137, 54, 0.1)', border: 'var(--color-warning)', text: 'var(--color-warning)' },
      info: { bg: 'rgba(66, 153, 225, 0.1)', border: 'var(--color-info)', text: 'var(--color-info)' }
    };
    const color = colors[type] || colors.info;
    statusElem.style.display = 'block';
    statusElem.style.background = color.bg;
    statusElem.style.borderLeft = `4px solid ${color.border}`;
    statusElem.style.color = color.text;
    statusElem.innerText = message;
  }

  async function testCloudConnection() {
    const settings = getCloudSettings();
    if (!settings.token) {
      showCloudStatus('‚ö†Ô∏è Please enter a GitHub token first', 'warning');
      return;
    }
    
    showCloudStatus('üîÑ Testing connection...', 'info');
    
    try {
      const response = await fetch('https://api.github.com/user', {
        headers: {
          'Authorization': `token ${settings.token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (response.ok) {
        const user = await response.json();
        showCloudStatus(`‚úÖ Connected as ${user.login}`, 'success');
      } else if (response.status === 401) {
        showCloudStatus('‚ùå Invalid token. Please check your token.', 'error');
      } else {
        showCloudStatus(`‚ùå Connection failed: ${response.statusText}`, 'error');
      }
    } catch (error) {
      showCloudStatus(`‚ùå Error: ${error.message}`, 'error');
    }
  }
  window.testCloudConnection = testCloudConnection;

  async function syncToCloud() {
    const settings = getCloudSettings();
    if (!settings.token) {
      if (confirm('Cloud sync not configured. Open settings to set it up?')) {
        showCloudSettings();
      }
      return;
    }
    
    if (!portfolio.length) {
      alert('No portfolio data to sync.');
      return;
    }
    
    if (!currentUser) {
      alert('Please login first.');
      return;
    }
    
    const dataToSync = {
      account: currentUser, // Store which account this data belongs to
      portfolio: portfolio,
      users: getUsers(),
      syncedAt: new Date().toISOString(),
      version: '1.0'
    };
    
    try {
      let gistId = settings.gistId;
      
      if (gistId) {
        // Update existing gist
        const response = await fetch(`https://api.github.com/gists/${gistId}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `token ${settings.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            files: {
              [CLOUD_GIST_FILENAME]: {
                content: JSON.stringify(dataToSync, null, 2)
              }
            }
          })
        });
        
        if (!response.ok) {
          if (response.status === 404) {
            // Gist not found, create new one
            gistId = null;
          } else {
            throw new Error(`Failed to update: ${response.statusText}`);
          }
        } else {
          alert('‚úÖ Portfolio synced to cloud successfully!');
          return;
        }
      }
      
      if (!gistId) {
        // Create new gist
        const response = await fetch('https://api.github.com/gists', {
          method: 'POST',
          headers: {
            'Authorization': `token ${settings.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            description: 'Stock Portfolio MTF Tracker - Portfolio Data',
            public: false,
            files: {
              [CLOUD_GIST_FILENAME]: {
                content: JSON.stringify(dataToSync, null, 2)
              }
            }
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to create: ${response.statusText}`);
        }
        
        const gist = await response.json();
        gistId = gist.id;
        settings.gistId = gistId;
        saveCloudSettings(settings);
        document.getElementById('gistId').value = gistId;
        
        alert(`‚úÖ Portfolio synced to cloud successfully!\n\nGist ID: ${gistId}\n\nSave this ID to sync from other devices.`);
      }
    } catch (error) {
      console.error('Cloud sync error:', error);
      alert(`‚ùå Failed to sync to cloud: ${error.message}\n\nPlease check your token and try again.`);
    }
  }
  window.syncToCloud = syncToCloud;

  async function syncFromCloud() {
    const settings = getCloudSettings();
    if (!settings.token) {
      if (confirm('Cloud sync not configured. Open settings to set it up?')) {
        showCloudSettings();
      }
      return;
    }
    
    let gistId = settings.gistId;
    if (!gistId) {
      gistId = prompt('Enter Gist ID to sync from:\n\n(Get this from another device after uploading to cloud)');
      if (!gistId) return;
      gistId = gistId.trim();
    }
    
    try {
      const response = await fetch(`https://api.github.com/gists/${gistId}`, {
        headers: {
          'Authorization': `token ${settings.token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error('Gist not found. Please check the Gist ID.');
        }
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }
      
      const gist = await response.json();
      const file = gist.files[CLOUD_GIST_FILENAME];
      
      if (!file) {
        throw new Error('Portfolio data file not found in gist.');
      }
      
      const data = JSON.parse(file.content);
      
      if (!data.portfolio || !Array.isArray(data.portfolio)) {
        throw new Error('Invalid data format.');
      }
      
      // Verify this data belongs to the current account
      if (data.account && data.account !== currentUser) {
        alert(`‚ö†Ô∏è This cloud data belongs to account "${data.account}", but you're logged in as "${currentUser}".\n\nPlease login with the correct account to sync this data.`);
        return;
      }
      
      if (!confirm(`Found ${data.portfolio.length} portfolio items for account "${currentUser}".\n\nThis will replace your current portfolio. Continue?`)) {
        return;
      }
      
      // Merge users data if available
      if (data.users) {
        const currentUsers = getUsers();
        const mergedUsers = { ...currentUsers, ...data.users };
        saveUsers(mergedUsers);
      }
      
      // Replace portfolio
      portfolio = data.portfolio.map(stock => {
        // Recalculate any missing fields
        const broker = stock.broker || 'POCKETFULL';
        const mtfFundsValue = Number(stock.mtfFunds || 0);
        const isMTF = typeof stock.isMTF === 'boolean' ? stock.isMTF : mtfFundsValue > 0;
        const computedRate = calculateBrokerDailyPercent(broker, mtfFundsValue);
        return {
          ...stock,
          broker,
          isMTF,
          interest: isMTF ? Number(stock.interest ?? computedRate) : 0,
          mtfFunds: isMTF ? mtfFundsValue : 0
        };
      });
      
      saveUserData();
      await renderPortfolio();
      
      alert(`‚úÖ Portfolio synced from cloud successfully!\n\nLoaded ${portfolio.length} items.\nSynced at: ${data.syncedAt || 'Unknown'}`);
    } catch (error) {
      console.error('Cloud sync error:', error);
      alert(`‚ùå Failed to sync from cloud: ${error.message}\n\nPlease check your token and Gist ID.`);
    }
  }
  window.syncFromCloud = syncFromCloud;

  // ====== GOOGLE DRIVE SYNC ======
  const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
  const GOOGLE_DRIVE_FILENAME = 'portfolio-data.json';
  const GOOGLE_DRIVE_MIMETYPE = 'application/json';
  
  let googleDriveAccessToken = null;
  let googleDriveFileId = null;

  // Initialize Google Drive API
  async function initGoogleDrive() {
    return new Promise((resolve, reject) => {
      if (typeof gapi === 'undefined') {
        reject(new Error('Google API not loaded'));
        return;
      }
      
      gapi.load('client', async () => {
        try {
          // Note: In production, you need to set your Google API Client ID
          // For now, we'll use a client-side approach with OAuth 2.0
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  // Authenticate with Google Drive using OAuth 2.0
  async function authenticateGoogleDrive() {
    return new Promise((resolve, reject) => {
      if (typeof google === 'undefined' || !google.accounts) {
        reject(new Error('Google Identity Services not loaded. Please refresh the page.'));
        return;
      }

      // Check if already authenticated and token is valid
      const savedToken = localStorage.getItem('stockapp_googledrive_token');
      const expiry = localStorage.getItem('stockapp_googledrive_token_expiry');
      const savedFileId = localStorage.getItem('stockapp_googledrive_fileid');
      
      if (savedToken && expiry && Date.now() < parseInt(expiry)) {
        googleDriveAccessToken = savedToken;
        googleDriveFileId = savedFileId;
        resolve(savedToken);
        return;
      }

      // Get client ID
      let clientId = localStorage.getItem('stockapp_googledrive_clientid');
      
      if (!clientId) {
        clientId = prompt(
          'Enter your Google OAuth Client ID:\n\n' +
          '1. Go to https://console.cloud.google.com/apis/credentials\n' +
          '2. Create OAuth 2.0 Client ID (Web application)\n' +
          '3. Add authorized JavaScript origins (your website URL)\n' +
          '4. Copy the Client ID here'
        );
        
        if (!clientId) {
          reject(new Error('Client ID required for Google Drive sync'));
          return;
        }
        
        localStorage.setItem('stockapp_googledrive_clientid', clientId);
      }

      // Use Google Identity Services for OAuth
      const tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: clientId,
        scope: GOOGLE_DRIVE_SCOPES,
        callback: (response) => {
          if (response.error) {
            reject(new Error(response.error));
            return;
          }
          googleDriveAccessToken = response.access_token;
          localStorage.setItem('stockapp_googledrive_token', response.access_token);
          if (response.expires_in) {
            const expiry = Date.now() + (response.expires_in * 1000);
            localStorage.setItem('stockapp_googledrive_token_expiry', expiry.toString());
          }
          resolve(response.access_token);
        }
      });
      tokenClient.requestAccessToken();
    });
  }

  // Find or create file in Google Drive
  async function findOrCreateDriveFile() {
    if (!googleDriveAccessToken) {
      await authenticateGoogleDrive();
    }

    // First, try to find existing file
    try {
      const response = await fetch('https://www.googleapis.com/drive/v3/files?q=name="' + GOOGLE_DRIVE_FILENAME + '" and trashed=false', {
        headers: {
          'Authorization': `Bearer ${googleDriveAccessToken}`,
          'Accept': 'application/json'
        }
      });

      if (response.ok) {
        const data = await response.json();
        if (data.files && data.files.length > 0) {
          googleDriveFileId = data.files[0].id;
          localStorage.setItem('stockapp_googledrive_fileid', googleDriveFileId);
          return googleDriveFileId;
        }
      }
    } catch (error) {
      console.log('Error finding file:', error);
    }

    // File not found, create new one
    try {
      const metadata = {
        name: GOOGLE_DRIVE_FILENAME,
        mimeType: GOOGLE_DRIVE_MIMETYPE
      };

      const response = await fetch('https://www.googleapis.com/drive/v3/files', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${googleDriveAccessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(metadata)
      });

      if (response.ok) {
        const file = await response.json();
        googleDriveFileId = file.id;
        localStorage.setItem('stockapp_googledrive_fileid', googleDriveFileId);
        return googleDriveFileId;
      } else {
        throw new Error('Failed to create file in Google Drive');
      }
    } catch (error) {
      throw new Error('Failed to create file: ' + error.message);
    }
  }

  // Upload data to Google Drive
  async function syncToGoogleDrive() {
    if (!currentUser) {
      alert('Please login first.');
      return;
    }

    if (!portfolio.length) {
      alert('No portfolio data to sync.');
      return;
    }

    try {
      // Authenticate
      await authenticateGoogleDrive();
      
      // Find or create file
      const fileId = await findOrCreateDriveFile();

      // Prepare data
      const dataToSync = {
        account: currentUser,
        portfolio: portfolio,
        users: getUsers(),
        syncedAt: new Date().toISOString(),
        version: '1.0'
      };

      const fileContent = JSON.stringify(dataToSync, null, 2);

      // Upload file content
      const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${googleDriveAccessToken}`,
          'Content-Type': GOOGLE_DRIVE_MIMETYPE
        },
        body: fileContent
      });

      if (response.ok) {
        alert('‚úÖ Portfolio synced to Google Drive successfully!');
        console.log('‚úì Data uploaded to Google Drive');
      } else {
        const error = await response.json();
        throw new Error(error.error?.message || 'Failed to upload to Google Drive');
      }
    } catch (error) {
      console.error('Google Drive sync error:', error);
      alert(`‚ùå Failed to sync to Google Drive: ${error.message}\n\nPlease make sure you have authenticated with Google Drive.`);
    }
  }
  window.syncToGoogleDrive = syncToGoogleDrive;

  // Download data from Google Drive
  async function syncFromGoogleDrive() {
    if (!currentUser) {
      alert('Please login first.');
      return;
    }

    try {
      // Authenticate
      await authenticateGoogleDrive();
      
      // Find file
      const fileId = await findOrCreateDriveFile();
      
      if (!fileId) {
        throw new Error('File not found in Google Drive');
      }

      // Download file content
      const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
        headers: {
          'Authorization': `Bearer ${googleDriveAccessToken}`,
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        if (response.status === 404) {
          throw new Error('File not found in Google Drive');
        }
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }

      const data = await response.json();
      
      if (!data.portfolio || !Array.isArray(data.portfolio)) {
        throw new Error('Invalid data format.');
      }

      // Verify account
      if (data.account && data.account !== currentUser) {
        alert(`‚ö†Ô∏è This data belongs to account "${data.account}", but you're logged in as "${currentUser}".\n\nPlease login with the correct account to sync this data.`);
        return;
      }

      if (!confirm(`Found ${data.portfolio.length} portfolio items for account "${currentUser}".\n\nThis will replace your current portfolio. Continue?`)) {
        return;
      }

      // Merge users data if available
      if (data.users) {
        const currentUsers = getUsers();
        const mergedUsers = { ...currentUsers, ...data.users };
        saveUsers(mergedUsers);
      }

      // Replace portfolio
      portfolio = data.portfolio.map(stock => {
        const broker = stock.broker || 'POCKETFULL';
        const mtfFundsValue = Number(stock.mtfFunds || 0);
        const isMTF = typeof stock.isMTF === 'boolean' ? stock.isMTF : mtfFundsValue > 0;
        const computedRate = calculateBrokerDailyPercent(broker, mtfFundsValue);
        return {
          ...stock,
          broker,
          isMTF,
          interest: isMTF ? Number(stock.interest ?? computedRate) : 0,
          mtfFunds: isMTF ? mtfFundsValue : 0
        };
      });

      saveUserData();
      await renderPortfolio();

      alert(`‚úÖ Portfolio synced from Google Drive successfully!\n\nLoaded ${portfolio.length} items.\nSynced at: ${data.syncedAt || 'Unknown'}`);
    } catch (error) {
      console.error('Google Drive sync error:', error);
      alert(`‚ùå Failed to sync from Google Drive: ${error.message}\n\nPlease make sure you have authenticated with Google Drive.`);
    }
  }
  window.syncFromGoogleDrive = syncFromGoogleDrive;


  const SEARCH_CONFIG = {
    minQueryLength: 2,
    debounceMs: 250
  };

  let searchDebounceTimer = null;
  let latestSearchToken = 0;

  // Company search data - fallback list if live search fails
  const stockDatabase = [
    {symbol: 'RELIANCE', name: 'Reliance Industries Limited'},
    {symbol: 'TCS', name: 'Tata Consultancy Services'},
    {symbol: 'HDFCBANK', name: 'HDFC Bank Limited'},
    {symbol: 'INFY', name: 'Infosys Limited'},
    {symbol: 'ICICIBANK', name: 'ICICI Bank Limited'},
    {symbol: 'HINDUNILVR', name: 'Hindustan Unilever Limited'},
    {symbol: 'ITC', name: 'ITC Limited'},
    {symbol: 'SBIN', name: 'State Bank of India'},
    {symbol: 'BHARTIARTL', name: 'Bharti Airtel Limited'},
    {symbol: 'KOTAKBANK', name: 'Kotak Mahindra Bank'},
    {symbol: 'LT', name: 'Larsen & Toubro Limited'},
    {symbol: 'AXISBANK', name: 'Axis Bank Limited'},
    {symbol: 'BAJFINANCE', name: 'Bajaj Finance Limited'},
    {symbol: 'ASIANPAINT', name: 'Asian Paints Limited'},
    {symbol: 'MARUTI', name: 'Maruti Suzuki India Limited'},
    {symbol: 'HCLTECH', name: 'HCL Technologies Limited'},
    {symbol: 'WIPRO', name: 'Wipro Limited'},
    {symbol: 'ULTRACEMCO', name: 'UltraTech Cement Limited'},
    {symbol: 'TITAN', name: 'Titan Company Limited'},
    {symbol: 'NESTLEIND', name: 'Nestle India Limited'},
    {symbol: 'TATAMOTORS', name: 'Tata Motors Limited'},
    {symbol: 'TATASTEEL', name: 'Tata Steel Limited'},
    {symbol: 'SUNPHARMA', name: 'Sun Pharmaceutical Industries'},
    {symbol: 'ONGC', name: 'Oil & Natural Gas Corporation'},
    {symbol: 'NTPC', name: 'NTPC Limited'},
    {symbol: 'POWERGRID', name: 'Power Grid Corporation'},
    {symbol: 'M&M', name: 'Mahindra & Mahindra Limited'},
    {symbol: 'ADANIPORTS', name: 'Adani Ports & SEZ Limited'},
    {symbol: 'JSWSTEEL', name: 'JSW Steel Limited'},
    {symbol: 'INDUSINDBK', name: 'IndusInd Bank Limited'}
  ];

  // Autocomplete functionality
  const searchInput = document.getElementById('companySearch');
  const dropdown = document.getElementById('autocompleteDropdown');
  const symbolInput = document.getElementById('symbol');
  const companyInput = document.getElementById('company');
  const brokerSelect = document.getElementById('broker');
  const mtfEnabledToggle = document.getElementById('mtfEnabled');
  const interestInput = document.getElementById('interest');
  const mtfFundsInput = document.getElementById('mtfFunds');
  const searchStatus = document.getElementById('searchStatus');
  const downloadCsvBtn = document.getElementById('downloadCsvBtn');
  const uploadCsvInput = document.getElementById('uploadCsvInput');

  function populateBrokerOptions() {
    if (!brokerSelect) return;
    brokerSelect.innerHTML = brokerCatalog.map((broker, index) => `
      <option value="${broker.id}" ${index === 0 ? 'selected' : ''}>
        ${broker.name} (${calculateBrokerDailyPercent(broker.id, 100000).toFixed(3)}%/day est.)
      </option>
    `).join('');
  }

  function updateInterestFromInputs() {
    if (!interestInput || !mtfFundsInput || !mtfEnabledToggle) return;
    if (!mtfEnabledToggle.checked) {
      interestInput.value = '0';
      return;
    }
    const brokerId = brokerSelect ? brokerSelect.value : brokerCatalog[0].id;
    const amount = parseFloat(mtfFundsInput.value || '0');
    const percent = calculateBrokerDailyPercent(brokerId, amount);
    interestInput.value = percent.toFixed(3);
  }

  function setSelectedStock(symbol, name) {
    if (!symbol || !name) return;
    const normalizedSymbol = symbol.toUpperCase();
    symbolInput.value = normalizedSymbol;
    companyInput.value = name;
    searchInput.value = name;
    dropdown.style.display = 'none';
  }

  function filterLocalStocks(query) {
    const normalized = query.toLowerCase();
    return stockDatabase.filter(stock =>
      stock.name.toLowerCase().includes(normalized) ||
      stock.symbol.toLowerCase().includes(normalized)
    ).slice(0, 8);
  }

  async function fetchSymbolSuggestions(query) {
    const qLower = query.toLowerCase();
    const sources = [
      {
        name: 'NSE Master List',
        fetcher: async () => {
          const url = `https://nsearchives.nseindia.com/content/equities/EQUITY_L.csv`;
          const res = await fetchWithOptionalProxy(url, { headers: { 'Accept': 'text/csv' } });
          const text = await res.text();
          const rows = parseCSV(text, ',');
          rows.shift();
          return rows
            .map(row => ({
              symbol: row[0],
              name: row[1]
            }))
            .filter(item =>
              item.symbol &&
              item.name &&
              (item.symbol.toLowerCase().includes(qLower) || item.name.toLowerCase().includes(qLower))
            )
            .slice(0, 20);
        }
      },
      {
        name: 'Angel Broking',
        fetcher: async () => {
          const url = `https://margincalculator.angelbroking.com/OpenAPI_File/files/NSE_Download.csv`;
          const res = await fetchWithOptionalProxy(url, { headers: { 'Accept': 'text/csv' } });
          const text = await res.text();
          const rows = parseCSV(text, ',');
          rows.shift();
          return rows
            .map(row => ({
              symbol: row[0],
              name: row[1]
            }))
            .filter(item =>
              item.symbol &&
              item.name &&
              (item.symbol.toLowerCase().includes(qLower) || item.name.toLowerCase().includes(qLower))
            )
            .slice(0, 20);
        }
      },
      {
        name: 'Moneycontrol',
        fetcher: async () => {
          const url = `https://priceapi.moneycontrol.com/mcfeed/nse/equitystocklist`;
          const res = await fetchWithOptionalProxy(url, { headers: { 'Accept': 'application/json' } });
          const data = await res.json();
          const list = data?.data || [];
          return list
            .map(item => ({
              symbol: item.SC_NAME?.toUpperCase(),
              name: item.SC_FULLNM || item.SC_NAME
            }))
            .filter(item =>
              item.symbol &&
              item.name &&
              (item.symbol.toLowerCase().includes(qLower) || item.name.toLowerCase().includes(qLower))
            )
            .slice(0, 20);
        }
      },
      {
        name: 'Yahoo Finance',
        fetcher: async () => {
          const url = `https://query2.finance.yahoo.com/v1/finance/search?q=${encodeURIComponent(query)}&lang=en-IN&region=IN`;
          const res = await fetchWithOptionalProxy(url, {
            headers: {
              'Accept': 'application/json',
              'User-Agent': 'Mozilla/5.0'
            }
          });
          const data = await res.json();
          const quotes = data?.quotes || [];
          return quotes
            .filter(q =>
              (q.exchDisp || '').toUpperCase().includes('NSE') ||
              (q.exchange || '').toUpperCase().includes('NS') ||
              (q.region || '').toUpperCase() === 'IN'
            )
            .map(q => ({
              symbol: (q.symbol || '').replace('.NS', '').toUpperCase(),
              name: q.shortname || q.longname || q.name || q.symbol || query.toUpperCase()
            }))
            .filter(item => item.symbol && item.name)
            .slice(0, 20);
        }
      }
    ];

    for (const source of sources) {
      setSearchStatus(`Searching ${source.name}...`, 'info');
      try {
        const result = await source.fetcher();
        if (result && result.length) {
          setSearchStatus(`Using results from ${source.name}`, 'success');
          return dedupeSuggestions(result);
        }
        setSearchStatus(`No matches from ${source.name}, trying next source...`, 'warning');
      } catch (err) {
        console.warn(`${source.name} suggestion source failed:`, err);
        setSearchStatus(`${source.name} unavailable, trying next source...`, 'warning');
      }
    }
    setSearchStatus('Showing cached suggestions (offline).', 'warning');
    return dedupeSuggestions(filterLocalStocks(query));
  }

  async function lookupSymbolDetails(symbol) {
    const clean = symbol.replace('.NS', '').trim();
    if (!clean) return null;
    const suggestions = await fetchSymbolSuggestions(clean);
    const normalized = clean.toUpperCase();
    return suggestions.find(s => s.symbol === normalized) ||
      suggestions.find(s => s.symbol?.startsWith(normalized)) ||
      suggestions[0] ||
      null;
  }

  function applyMTFState() {
    if (!mtfEnabledToggle || !mtfFundsInput || !interestInput) return;
    const enabled = mtfEnabledToggle.checked;
    if (enabled) {
      mtfFundsInput.removeAttribute('disabled');
      interestInput.removeAttribute('disabled');
      updateInterestFromInputs();
    } else {
      mtfFundsInput.value = '0';
      mtfFundsInput.setAttribute('disabled', 'disabled');
      interestInput.value = '0';
      interestInput.setAttribute('disabled', 'disabled');
    }
  }

  function handleBrokerChange() {
    if (!brokerSelect || !interestInput) return;
    updateInterestFromInputs();
  }

  async function renderSuggestions(query, token) {
    try {
      const matches = await fetchSymbolSuggestions(query);
      if (token !== latestSearchToken) return;
      if (!matches.length) {
        dropdown.style.display = 'none';
        return;
      }
      dropdown.innerHTML = matches.map(stock => `
        <div class="autocomplete-item" data-symbol="${stock.symbol}" data-name="${stock.name}">
          <strong>${stock.symbol}</strong>
          <small>${stock.name}</small>
        </div>
      `).join('');
      dropdown.style.display = 'block';
      dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
        item.addEventListener('click', function() {
          setSelectedStock(this.dataset.symbol, this.dataset.name);
        });
      });
    } catch (error) {
      console.error('Autocomplete error:', error);
      dropdown.style.display = 'none';
    }
  }

  searchInput.addEventListener('input', function() {
    const query = this.value.trim();
    if (query.length < SEARCH_CONFIG.minQueryLength) {
      dropdown.style.display = 'none';
      setSearchStatus('Type at least 2 characters to search NSE listings.', 'info');
      return;
    }
    setSearchStatus('Gathering suggestions...', 'info');
    if (searchDebounceTimer) clearTimeout(searchDebounceTimer);
    searchDebounceTimer = setTimeout(() => {
      latestSearchToken += 1;
      renderSuggestions(query, latestSearchToken);
    }, SEARCH_CONFIG.debounceMs);
  });

  symbolInput.addEventListener('change', async function() {
    const value = this.value.trim();
    if (!value) {
      companyInput.value = '';
      setSearchStatus('Enter a symbol or company name to search.', 'info');
      return;
    }
    setSearchStatus('Validating symbol...', 'info');
    try {
      const match = await lookupSymbolDetails(value);
      if (match) {
        setSelectedStock(match.symbol, match.name);
        setSearchStatus(`Symbol resolved via live lookup.`, 'success');
      } else {
        alert("Couldn't find that symbol on NSE. Please check the value.");
        companyInput.value = '';
        setSearchStatus('Symbol not found on any source.', 'error');
      }
    } catch (error) {
      console.error('Symbol lookup failed:', error);
      setSearchStatus('Symbol lookup failed. Please try again.', 'error');
    }
  });

  if (brokerSelect) {
    brokerSelect.addEventListener('change', handleBrokerChange);
  }
  if (mtfEnabledToggle) {
    mtfEnabledToggle.addEventListener('change', applyMTFState);
  }
  if (mtfFundsInput) {
    mtfFundsInput.addEventListener('input', updateInterestFromInputs);
  }
  if (downloadCsvBtn) {
    downloadCsvBtn.addEventListener('click', handleDownloadCSV);
  }
  if (uploadCsvInput) {
    uploadCsvInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      handleUploadCSVFile(file);
    });
  }
  
  const syncToCloudBtn = document.getElementById('syncToCloudBtn');
  const syncFromCloudBtn = document.getElementById('syncFromCloudBtn');
  const cloudSettingsBtn = document.getElementById('cloudSettingsBtn');
  
  if (syncToCloudBtn) {
    syncToCloudBtn.addEventListener('click', syncToCloud);
  }
  if (syncFromCloudBtn) {
    syncFromCloudBtn.addEventListener('click', syncFromCloud);
  }
  if (cloudSettingsBtn) {
    cloudSettingsBtn.addEventListener('click', showCloudSettings);
  }
  
  const syncToDriveBtn = document.getElementById('syncToDriveBtn');
  const syncFromDriveBtn = document.getElementById('syncFromDriveBtn');
  
  if (syncToDriveBtn) {
    syncToDriveBtn.addEventListener('click', syncToGoogleDrive);
  }
  if (syncFromDriveBtn) {
    syncFromDriveBtn.addEventListener('click', syncFromGoogleDrive);
  }

  document.addEventListener('click', function(e) {
    if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
      dropdown.style.display = 'none';
    }
  });

  // Enhance fetch with optional public proxy for CORS-restricted origins
  const corsProxies = [
    'https://functions.yandexcloud.net/d4e8o7c05orql99drbqg?url=',
    'https://thingproxy.freeboard.io/fetch/',
    'https://api.allorigins.win/raw?url='
  ];

  async function fetchWithOptionalProxy(url, options = {}) {
    try {
      const res = await fetch(url, options);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res;
    } catch (err) {
      for (const proxy of corsProxies) {
        try {
          const proxyRes = await fetch(proxy + encodeURIComponent(url), options);
          if (proxyRes.ok) {
            return proxyRes;
          }
        } catch (_) {
          // try next proxy
        }
      }
      throw err;
    }
  }

  // Enhanced price fetch with multiple fallback APIs and comprehensive error handling
  async function fetchNSEPrice(symbol) {
    if (!symbol) return null;
    
    const cleanSymbol = symbol.replace('.NS', '').toUpperCase();
    
    // Try multiple APIs in sequence for reliability
    const apis = [
      // API 1: Yahoo Finance (most reliable)
      async () => {
        const url = `https://query1.finance.yahoo.com/v8/finance/chart/${cleanSymbol}.NS?interval=1d&range=5d`;
        const res = await fetchWithOptionalProxy(url, {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
          }
        });
        if (!res.ok) throw new Error('Yahoo API failed');
        const data = await res.json();
        const meta = data?.chart?.result?.[0]?.meta || {};
        let price = meta.regularMarketPrice ?? meta.previousClose ?? meta.chartPreviousClose;
        if (!price) {
          const closes = data?.chart?.result?.[0]?.indicators?.quote?.[0]?.close || [];
          price = closes.filter(v => typeof v === 'number' && !isNaN(v)).pop();
        }
        if (!price) throw new Error('No price data');
        return Number(price);
      },
      
      // API 2: Alternative NSE data source
      async () => {
        const url = `https://www.nseindia.com/api/quote-equity?symbol=${cleanSymbol}`;
        const res = await fetchWithOptionalProxy(url, {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0'
          }
        });
        if (!res.ok) throw new Error('NSE API failed');
        const data = await res.json();
        const price = data?.priceInfo?.lastPrice || data?.priceInfo?.previousClose || data?.lastPrice;
        if (!price) throw new Error('No price data');
        return Number(price);
      },
      
      // API 3: MoneyControl (original)
      async () => {
        const url = `https://priceapi.moneycontrol.com/pricefeed/nse/equitycash/${cleanSymbol}`;
        const res = await fetchWithOptionalProxy(url, {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0'
          }
        });
        if (!res.ok) throw new Error('MoneyControl API failed');
        const data = await res.json();
        const price = data?.data?.pricecurrent || data?.data?.priceprevclose || data?.pricecurrent;
        if (!price) throw new Error('No price data');
        return Number(price);
      }
    ];
    
    // Try each API until one succeeds
    for (let i = 0; i < apis.length; i++) {
      try {
        const price = await apis[i]();
        if (price && !isNaN(price) && price > 0) {
          console.log(`‚úì Price fetched for ${cleanSymbol}: ‚Çπ${price} (API ${i+1})`);
          return price;
        }
      } catch (error) {
        console.warn(`API ${i+1} failed for ${cleanSymbol}:`, error.message);
        // Continue to next API
      }
    }
    
    // All APIs failed
    console.error(`‚úó All APIs failed for symbol: ${cleanSymbol}`);
    return null;
  }

  // STATE
  let portfolio = [];
  let currentUser = null;
  let currentUserDisplayName = '';
  const chartRefs = {
    allocation: null,
    profit: null,
    broker: null
  };
  const CSV_HEADERS = ['symbol','company','broker','isMTF','entryDate','entryPrice','quantity','ownCapital','mtfFunds','interest'];
  const STORAGE_KEYS = {
    USERS: 'stockapp_users',
    CURRENT_USER: 'stockapp_current_user',
    CURRENT_USER_DISPLAY: 'stockapp_current_user_display',
    REMEMBERED_USERS: 'stockapp_remembered_users',
    REMEMBERED_LAST: 'stockapp_last_remembered_user',
    REGISTERED_DEVICES: 'stockapp_registered_devices',
    DEVICE_LIMIT: 'stockapp_device_limit'
  };
  const LOGIN_SECURITY = {
    maxAttempts: 5,
    lockoutMinutes: 5
  };
  const DEVICE_CONFIG = {
    MAX_DEVICES: 3, // Maximum number of devices allowed
    ADMIN_PASSWORD: 'admin123' // Change this to your secure password
  };

  // ====== DEVICE MANAGEMENT ======
  function generateDeviceId() {
    // Create a unique device fingerprint
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('Device fingerprint', 2, 2);
    
    const fingerprint = [
      navigator.userAgent,
      navigator.language,
      screen.width + 'x' + screen.height,
      new Date().getTimezoneOffset(),
      canvas.toDataURL(),
      navigator.hardwareConcurrency || 'unknown'
    ].join('|');
    
    // Hash the fingerprint
    let hash = 0;
    for (let i = 0; i < fingerprint.length; i++) {
      const char = fingerprint.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return 'device_' + Math.abs(hash).toString(36);
  }

  function getDeviceId() {
    let deviceId = localStorage.getItem('stockapp_device_id');
    if (!deviceId) {
      deviceId = generateDeviceId();
      localStorage.setItem('stockapp_device_id', deviceId);
    }
    return deviceId;
  }

  function getRegisteredDevices() {
    return JSON.parse(localStorage.getItem(STORAGE_KEYS.REGISTERED_DEVICES) || '[]');
  }

  function saveRegisteredDevices(devices) {
    localStorage.setItem(STORAGE_KEYS.REGISTERED_DEVICES, JSON.stringify(devices));
  }

  function isDeviceRegistered() {
    const deviceId = getDeviceId();
    const registered = getRegisteredDevices();
    return registered.some(d => d.id === deviceId);
  }

  function registerDevice(deviceName = '') {
    const deviceId = getDeviceId();
    const registered = getRegisteredDevices();
    
    if (registered.length >= DEVICE_CONFIG.MAX_DEVICES) {
      return { success: false, message: `Maximum ${DEVICE_CONFIG.MAX_DEVICES} devices allowed. Please remove an existing device first.` };
    }
    
    if (registered.some(d => d.id === deviceId)) {
      return { success: true, message: 'Device already registered.' };
    }
    
    registered.push({
      id: deviceId,
      name: deviceName || `Device ${registered.length + 1}`,
      registeredAt: new Date().toISOString(),
      userAgent: navigator.userAgent.substring(0, 100)
    });
    
    saveRegisteredDevices(registered);
    return { success: true, message: 'Device registered successfully!' };
  }

  function removeDevice(deviceId) {
    const registered = getRegisteredDevices();
    const filtered = registered.filter(d => d.id !== deviceId);
    saveRegisteredDevices(filtered);
    return filtered;
  }

  function showDeviceRegistration() {
    document.getElementById('deviceScreen').style.display = 'block';
    document.getElementById('loginScreen').style.display = 'none';
    document.getElementById('signupScreen').style.display = 'none';
    document.getElementById('mainApp').style.display = 'none';
    document.getElementById('deviceBackButton').style.display = 'none';
  }

  function hideDeviceRegistration() {
    document.getElementById('deviceScreen').style.display = 'none';
  }

  function showDeviceManagement() {
    renderDeviceList();
    document.getElementById('deviceScreen').style.display = 'block';
    document.getElementById('mainApp').style.display = 'none';
    document.getElementById('deviceBackButton').style.display = 'block';
    // Clear form fields
    document.getElementById('deviceName').value = '';
    document.getElementById('deviceError').style.display = 'none';
  }
  window.showDeviceManagement = showDeviceManagement;

  function backToApp() {
    if (currentUser) {
      showMainApp();
    } else {
      showLoginForm();
    }
  }
  window.backToApp = backToApp;

  function renderDeviceList() {
    const devices = getRegisteredDevices();
    const currentDeviceId = getDeviceId();
    const countElem = document.getElementById('deviceCount');
    const listElem = document.getElementById('deviceListItems');
    
    if (countElem) countElem.textContent = devices.length;
    
    if (!listElem) return;
    
    if (devices.length === 0) {
      listElem.innerHTML = '<p style="text-align: center; color: var(--color-text-light); font-size: 13px;">No devices registered yet.</p>';
      return;
    }
    
    listElem.innerHTML = devices.map(device => {
      const isCurrent = device.id === currentDeviceId;
      const date = new Date(device.registeredAt).toLocaleDateString();
      return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 8px; background: ${isCurrent ? 'rgba(102, 126, 234, 0.1)' : 'var(--color-card-bg)'}; border-radius: 8px; border: 1px solid var(--color-border);">
          <div style="flex: 1;">
            <div style="font-weight: 600; font-size: 14px;">${device.name} ${isCurrent ? '<span style="color: var(--color-success);">(Current)</span>' : ''}</div>
            <div style="font-size: 12px; color: var(--color-text-light); margin-top: 4px;">Registered: ${date}</div>
          </div>
          ${!isCurrent ? `<button onclick="removeDeviceById('${device.id}')" style="background: var(--color-danger); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Remove</button>` : ''}
        </div>
      `;
    }).join('');
  }

  function removeDeviceById(deviceId) {
    if (!confirm('Are you sure you want to remove this device? It will need to be registered again to access the app.')) {
      return;
    }
    removeDevice(deviceId);
    renderDeviceList();
  }
  window.removeDeviceById = removeDeviceById;

  function handleDeviceRegistration() {
    const deviceName = document.getElementById('deviceName').value.trim() || `Device ${getRegisteredDevices().length + 1}`;
    const errorElem = document.getElementById('deviceError');
    
    errorElem.style.display = 'none';
    
    // Auto-register device (no password required - just for tracking)
    const result = registerDevice(deviceName);
    if (result.success) {
      errorElem.innerText = '‚úÖ ' + result.message;
      errorElem.style.color = 'var(--color-success)';
      errorElem.style.background = 'rgba(72, 187, 120, 0.1)';
      errorElem.style.display = 'block';
      renderDeviceList();
      setTimeout(() => {
        hideDeviceRegistration();
        showLoginForm();
      }, 1500);
    } else {
      errorElem.innerText = '‚ùå ' + result.message;
      errorElem.style.display = 'block';
    }
  }

  // Auto-register device when user logs in (for tracking purposes)
  function autoRegisterDeviceOnLogin() {
    if (!currentUser) return;
    const deviceId = getDeviceId();
    const registered = getRegisteredDevices();
    
    // Check if already registered
    if (registered.some(d => d.id === deviceId)) {
      return; // Already registered
    }
    
    // Auto-register if under limit
    if (registered.length < DEVICE_CONFIG.MAX_DEVICES) {
      const deviceName = `${navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'} Device`;
      registerDevice(deviceName);
      console.log('‚úì Device auto-registered for tracking');
    }
  }

  // ====== HELPERS ======
  function normalizeUsername(username = '') {
    return username.trim().toLowerCase();
  }

  function getUsers() {
    return JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '{}');
  }

  function saveUsers(users) {
    localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(users));
  }

  function getRememberedUsers() {
    return JSON.parse(localStorage.getItem(STORAGE_KEYS.REMEMBERED_USERS) || '{}');
  }

  function saveRememberedUsers(data) {
    localStorage.setItem(STORAGE_KEYS.REMEMBERED_USERS, JSON.stringify(data));
  }

  function isUserRemembered(username) {
    const remembered = getRememberedUsers();
    return !!remembered[username];
  }

  function setUserRemembered(username, remember) {
    const remembered = getRememberedUsers();
    if (remember) {
      remembered[username] = true;
      localStorage.setItem(STORAGE_KEYS.REMEMBERED_LAST, username);
    } else {
      delete remembered[username];
      const last = localStorage.getItem(STORAGE_KEYS.REMEMBERED_LAST);
      if (last === username) {
        localStorage.removeItem(STORAGE_KEYS.REMEMBERED_LAST);
      }
    }
    saveRememberedUsers(remembered);
  }

  function showLoginError(message, type = 'error') {
    const errorElem = document.getElementById('loginError');
    const colors = {
      error: { text: 'var(--color-danger)', bg: 'rgba(245, 101, 101, 0.1)' },
      warning: { text: 'var(--color-warning)', bg: 'rgba(237, 137, 54, 0.1)' },
      success: { text: 'var(--color-success)', bg: 'rgba(72, 187, 120, 0.1)' }
    };
    const palette = colors[type] || colors.error;
    errorElem.innerText = message;
    errorElem.style.display = 'block';
    errorElem.style.color = palette.text;
    errorElem.style.background = palette.bg;
  }

  function setLoginButtonBusy(isBusy) {
    const btn = document.getElementById('loginButton');
    if (!btn) return;
    btn.disabled = isBusy;
    btn.style.opacity = isBusy ? '0.7' : '1';
    btn.innerText = isBusy ? 'Signing in...' : 'Sign in';
  }

  function resolveUserRecord(users, username) {
    if (users[username]) {
      return { key: username, record: users[username] };
    }
    const normalized = normalizeUsername(username);
    if (users[normalized]) {
      return { key: normalized, record: users[normalized] };
    }
    return { key: normalized, record: null };
  }

  function promptRememberDevice(username) {
    if (isUserRemembered(username)) return;
    const remember = confirm("Remember this device so you don't have to enter your password next time?");
    if (remember) {
      setUserRemembered(username, true);
      alert("‚úÖ We'll keep you signed in on this device. Logout anytime to switch accounts.");
    }
  }

  // ====== TOKEN-BASED AUTHENTICATION SYSTEM ======
  // Client-side JWT-like token system for stateless, multi-device authentication
  
  const TOKEN_CONFIG = {
    ACCESS_TOKEN_EXPIRY: 60 * 60 * 1000, // 1 hour (short-lived)
    REFRESH_TOKEN_EXPIRY: 7 * 24 * 60 * 60 * 1000, // 7 days (long-lived)
    TOKEN_SECRET_KEY: 'stockapp_token_secret_2024' // In production, this should be server-side
  };

  // Generate a simple token (client-side JWT-like structure)
  async function generateToken(payload, expiresIn) {
    const header = {
      alg: 'HS256',
      typ: 'JWT'
    };
    
    const now = Date.now();
    const tokenPayload = {
      ...payload,
      iat: now, // Issued at
      exp: now + expiresIn // Expires at
    };
    
    // Simple base64 encoding (in production, use proper JWT library with signing)
    const encodedHeader = btoa(JSON.stringify(header));
    const encodedPayload = btoa(JSON.stringify(tokenPayload));
    
    // Create a simple signature (in production, use HMAC-SHA256)
    const hash = await hashPassword(encodedHeader + encodedPayload + TOKEN_CONFIG.TOKEN_SECRET_KEY);
    const signature = btoa(JSON.stringify({ hash }));
    
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  }

  // Validate and decode token
  async function validateToken(token) {
    if (!token) return null;
    
    try {
      const parts = token.split('.');
      if (parts.length !== 3) return null;
      
      const [encodedHeader, encodedPayload, encodedSignature] = parts;
      
      // Decode payload
      const payload = JSON.parse(atob(encodedPayload));
      
      // Check expiration
      if (payload.exp && Date.now() > payload.exp) {
        return { valid: false, expired: true };
      }
      
      // Verify signature (simplified client-side check)
      const expectedSignature = btoa(JSON.stringify({
        hash: await hashPassword(encodedHeader + encodedPayload + TOKEN_CONFIG.TOKEN_SECRET_KEY)
      }));
      
      if (encodedSignature !== expectedSignature) {
        return { valid: false, invalid: true };
      }
      
      return { valid: true, payload };
    } catch (error) {
      console.error('Token validation error:', error);
      return null;
    }
  }

  // Store tokens securely
  function storeTokens(accessToken, refreshToken) {
    localStorage.setItem('stockapp_access_token', accessToken);
    localStorage.setItem('stockapp_refresh_token', refreshToken);
    localStorage.setItem('stockapp_tokens_issued_at', Date.now().toString());
  }

  // Get stored tokens
  function getStoredTokens() {
    return {
      accessToken: localStorage.getItem('stockapp_access_token'),
      refreshToken: localStorage.getItem('stockapp_refresh_token')
    };
  }

  // Clear tokens (logout)
  function clearTokens() {
    localStorage.removeItem('stockapp_access_token');
    localStorage.removeItem('stockapp_refresh_token');
    localStorage.removeItem('stockapp_tokens_issued_at');
  }

  // Refresh access token using refresh token
  async function refreshAccessToken() {
    const { refreshToken } = getStoredTokens();
    if (!refreshToken) return null;
    
    const validation = await validateToken(refreshToken);
    if (!validation || !validation.valid) {
      // Refresh token expired or invalid - user needs to login again
      clearTokens();
      return null;
    }
    
    // Generate new access token
    const newAccessToken = await generateToken(
      { userId: validation.payload.userId, username: validation.payload.username },
      TOKEN_CONFIG.ACCESS_TOKEN_EXPIRY
    );
    
    // Store new access token
    localStorage.setItem('stockapp_access_token', newAccessToken);
    localStorage.setItem('stockapp_tokens_issued_at', Date.now().toString());
    
    return newAccessToken;
  }

  // Get valid access token (auto-refresh if needed)
  async function getValidAccessToken() {
    const { accessToken } = getStoredTokens();
    
    if (!accessToken) {
      // Try to refresh
      return await refreshAccessToken();
    }
    
    const validation = await validateToken(accessToken);
    
    if (!validation || !validation.valid) {
      if (validation?.expired) {
        // Access token expired, try to refresh
        return await refreshAccessToken();
      }
      // Token invalid, clear and return null
      clearTokens();
      return null;
    }
    
    return accessToken;
  }

  // Check if user is authenticated (has valid tokens)
  async function isAuthenticated() {
    const accessToken = await getValidAccessToken();
    if (!accessToken) return false;
    
    const validation = await validateToken(accessToken);
    return validation?.valid === true;
  }

  // Get current user from token
  async function getCurrentUserFromToken() {
    const accessToken = await getValidAccessToken();
    if (!accessToken) return null;
    
    const validation = await validateToken(accessToken);
    if (!validation || !validation.valid) return null;
    
    return {
      userId: validation.payload.userId,
      username: validation.payload.username
    };
  }

  // ====== USER AUTHENTICATION ======
  // Password hashing using SHA-256
  async function hashPassword(password) {
    const msgBuffer = new TextEncoder().encode(password);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
  }

  // Show/hide forms
  function showSignupForm() {
    document.getElementById('deviceScreen').style.display = 'none';
    document.getElementById('loginScreen').style.display = 'none';
    document.getElementById('mainApp').style.display = 'none';
    document.getElementById('signupScreen').style.display = 'block';
  }

  function showLoginForm() {
    document.getElementById('deviceScreen').style.display = 'none';
    document.getElementById('signupScreen').style.display = 'none';
    document.getElementById('mainApp').style.display = 'none';
    document.getElementById('loginScreen').style.display = 'block';
  }

  async function handleLogin() {
    const usernameInput = document.getElementById('loginUsername');
    const passwordInput = document.getElementById('loginPassword');
    const username = usernameInput.value.trim();
    const password = passwordInput.value;
    document.getElementById('loginError').style.display = 'none';
    
    if (!username) {
      showLoginError("‚ö†Ô∏è Please enter your username", 'warning');
      return;
    }
    
    if (username.length < 3) {
      showLoginError("‚ö†Ô∏è Username must be at least 3 characters long", 'warning');
      return;
    }
    
    setLoginButtonBusy(true);
    try {
      const users = getUsers();
      const { key, record } = resolveUserRecord(users, username);
      
      if (!record) {
        showLoginError("‚ùå Account not found. Please create a new account.");
        return;
      }
      
      if (record.lockedUntil && Date.now() < record.lockedUntil) {
        const minutesLeft = Math.ceil((record.lockedUntil - Date.now()) / 60000);
        showLoginError(`‚è≥ Too many attempts. Try again in ${minutesLeft} minute${minutesLeft === 1 ? '' : 's'}.`, 'warning');
        return;
      }
      
      const rememberedBypass = isUserRemembered(key);
      if (!password && !rememberedBypass) {
        showLoginError("‚ö†Ô∏è Please enter your password or enable Remember Me first.", 'warning');
        return;
      }
      
      let passwordValid = rememberedBypass;
      if (!rememberedBypass) {
        const hashedPassword = await hashPassword(password);
        passwordValid = record.password === hashedPassword;
      }
      
      if (!passwordValid) {
        record.failedAttempts = (record.failedAttempts || 0) + 1;
        if (record.failedAttempts >= LOGIN_SECURITY.maxAttempts) {
          record.lockedUntil = Date.now() + LOGIN_SECURITY.lockoutMinutes * 60000;
          showLoginError(`‚õî Account locked for ${LOGIN_SECURITY.lockoutMinutes} minutes due to repeated failures.`);
        } else {
          const remaining = LOGIN_SECURITY.maxAttempts - record.failedAttempts;
          showLoginError(`‚ùå Incorrect password. ${remaining} attempt${remaining === 1 ? '' : 's'} remaining.`);
        }
        saveUsers(users);
        return;
      }
      
      // Successful login - Generate tokens (JWT-like system)
      record.failedAttempts = 0;
      delete record.lockedUntil;
      record.lastLogin = new Date().toISOString();
      saveUsers(users);
      
      usernameInput.value = '';
      passwordInput.value = '';
      
      // Generate Access Token (short-lived: 1 hour)
      const accessToken = await generateToken(
        { userId: key, username: key, displayName: record.displayName || username },
        TOKEN_CONFIG.ACCESS_TOKEN_EXPIRY
      );
      
      // Generate Refresh Token (long-lived: 7 days)
      const refreshToken = await generateToken(
        { userId: key, username: key, type: 'refresh' },
        TOKEN_CONFIG.REFRESH_TOKEN_EXPIRY
      );
      
      // Store tokens securely
      storeTokens(accessToken, refreshToken);
      
      // Also store user info for backward compatibility
      currentUser = key;
      currentUserDisplayName = record.displayName || username;
      localStorage.setItem(STORAGE_KEYS.CURRENT_USER, key);
      localStorage.setItem(STORAGE_KEYS.CURRENT_USER_DISPLAY, currentUserDisplayName);
      
      // Load user data (will auto-sync from cloud if configured)
      await loadUserData();
      await showMainApp();
      promptRememberDevice(key);
    } catch (err) {
      console.error('Login failed:', err);
      showLoginError("‚ùå Something went wrong while signing in. Please try again.");
    } finally {
      setLoginButtonBusy(false);
    }
  }
  
  async function handleSignup() {
    const usernameRaw = document.getElementById('signupUsername').value.trim();
    const username = usernameRaw;
    const password = document.getElementById('signupPassword').value;
    const confirmPassword = document.getElementById('signupPasswordConfirm').value;
    const errorElem = document.getElementById('signupError');
    
    errorElem.style.display = 'none';
    
    // Basic validation
    if (!username || !password || !confirmPassword) {
      errorElem.innerText = "‚ö†Ô∏è Please fill all fields";
      errorElem.style.display = 'block';
      return;
    }
    
    if (password !== confirmPassword) {
      errorElem.innerText = "‚ö†Ô∏è Passwords do not match";
      errorElem.style.display = 'block';
      return;
    }
    
    const users = getUsers();
    const normalized = normalizeUsername(username);
    if (users[username] || users[normalized]) {
      errorElem.innerText = "‚ùå Username already exists. Please choose another or sign in.";
      errorElem.style.display = 'block';
      return;
    }
    
    // Create new user with hashed password
    const hashedPassword = await hashPassword(password);
    users[normalized] = {
      password: hashedPassword,
      created: new Date().toISOString(),
      lastLogin: new Date().toISOString(),
      displayName: username,
      failedAttempts: 0
    };
    
    saveUsers(users);
    localStorage.setItem(`stockapp_portfolio_${normalized}`, JSON.stringify([]));
    
    // Clear signup form fields
    document.getElementById('signupUsername').value = '';
    document.getElementById('signupPassword').value = '';
    document.getElementById('signupPasswordConfirm').value = '';
    const strengthMeterSignup = document.getElementById('passwordStrength');
    if (strengthMeterSignup) strengthMeterSignup.style.display = 'none';
    
    // Generate tokens for new user (JWT-like system)
    const accessToken = await generateToken(
      { userId: normalized, username: normalized, displayName: username },
      TOKEN_CONFIG.ACCESS_TOKEN_EXPIRY
    );
    
    const refreshToken = await generateToken(
      { userId: normalized, username: normalized, type: 'refresh' },
      TOKEN_CONFIG.REFRESH_TOKEN_EXPIRY
    );
    
    // Store tokens securely
    storeTokens(accessToken, refreshToken);
    
    // Also store user info for backward compatibility
    currentUser = normalized;
    currentUserDisplayName = username;
    localStorage.setItem(STORAGE_KEYS.CURRENT_USER, normalized);
    localStorage.setItem(STORAGE_KEYS.CURRENT_USER_DISPLAY, username);
    // Load user data (will auto-sync from cloud if configured)
    await loadUserData();
    await showMainApp();
  }

  function handleLogout() {
    saveUserData();
    // Clear all tokens (revoke access)
    clearTokens();
    currentUser = null;
    currentUserDisplayName = '';
    localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);
    localStorage.removeItem(STORAGE_KEYS.CURRENT_USER_DISPLAY);
    portfolio = [];
    document.getElementById('mainApp').style.display = 'none';
    document.getElementById('signupScreen').style.display = 'none';
    document.getElementById('loginScreen').style.display = 'block';
    
    // Clear all login/signup form fields for security
    document.getElementById('loginUsername').value = '';
    document.getElementById('loginPassword').value = '';
    document.getElementById('signupUsername').value = '';
    document.getElementById('signupPassword').value = '';
    document.getElementById('signupPasswordConfirm').value = '';
    const strengthMeterLogout = document.getElementById('passwordStrength');
    if (strengthMeterLogout) strengthMeterLogout.style.display = 'none';
    if (mtfEnabledToggle) {
      mtfEnabledToggle.checked = true;
      applyMTFState();
    }
    handleBrokerChange();
    
    // Clear error messages
    document.getElementById('loginError').innerText = '';
    document.getElementById('loginError').style.display = 'none';
    document.getElementById('signupError').innerText = '';
    document.getElementById('signupError').style.display = 'none';
  }

  async function showMainApp() {
    document.getElementById('deviceScreen').style.display = 'none';
    document.getElementById('loginScreen').style.display = 'none';
    document.getElementById('signupScreen').style.display = 'none';
    document.getElementById('mainApp').style.display = 'block';
    document.getElementById('displayUsername').innerText = currentUserDisplayName || currentUser || '';
    // Auto-register device for tracking (optional, non-blocking)
    autoRegisterDeviceOnLogin();
    // Load user data (will auto-sync from cloud if configured)
    await loadUserData();
    await renderPortfolio();
    
    // Show cloud sync notification if not configured
    checkAndShowCloudSyncNotification();
  }

  function checkAndShowCloudSyncNotification() {
    const notification = document.getElementById('cloudSyncNotification');
    if (!notification) return;
    
    const dismissed = localStorage.getItem('stockapp_cloud_sync_notification_dismissed') === 'true';
    if (dismissed) {
      notification.style.display = 'none';
      return;
    }
    
    const settings = getCloudSettings();
    if (!settings.token || !settings.gistId) {
      // Cloud sync not configured - show notification
      notification.style.display = 'block';
    } else {
      // Cloud sync configured - hide notification
      notification.style.display = 'none';
    }
  }

  async function saveUserData(autoSync = true) {
    if (currentUser) {
      localStorage.setItem(`stockapp_portfolio_${currentUser}`, JSON.stringify(portfolio));
      
      // Auto-sync to cloud if configured (silently in background)
      if (autoSync) {
        const settings = getCloudSettings();
        if (settings.token && settings.gistId && portfolio.length > 0) {
          // Sync in background without blocking
          syncToCloudSilent().catch(err => {
            console.log('Auto-sync failed (non-critical):', err.message);
          });
        }
      }
    }
  }

  async function loadUserData(autoSync = true) {
    if (currentUser) {
      const saved = localStorage.getItem(`stockapp_portfolio_${currentUser}`);
      portfolio = saved ? JSON.parse(saved) : [];
      portfolio = portfolio.map(stock => {
        const broker = stock.broker || 'POCKETFULL';
        const mtfFundsValue = Number(stock.mtfFunds || 0);
        const isMTF = typeof stock.isMTF === 'boolean' ? stock.isMTF : mtfFundsValue > 0;
        const computedRate = calculateBrokerDailyPercent(broker, mtfFundsValue);
        return {
          ...stock,
          broker,
          isMTF,
          interest: isMTF ? Number(stock.interest ?? computedRate) : 0,
          mtfFunds: isMTF ? mtfFundsValue : 0
        };
      });
      
      // Auto-sync from cloud on login if configured
      if (autoSync) {
        const settings = getCloudSettings();
        if (settings.token && settings.gistId) {
          // Try to sync from cloud silently, merge if newer data exists
          try {
            await syncFromCloudSilent();
          } catch (err) {
            console.log('Auto-sync from cloud failed (using local data):', err.message);
          }
        }
      }
    }
  }

  // Silent cloud sync functions (no alerts, for automatic sync)
  async function syncToCloudSilent() {
    const settings = getCloudSettings();
    if (!settings.token || !portfolio.length || !currentUser) return;
    
    const dataToSync = {
      account: currentUser, // Store which account this data belongs to
      portfolio: portfolio,
      users: getUsers(),
      syncedAt: new Date().toISOString(),
      version: '1.0'
    };
    
    let gistId = settings.gistId;
    
    if (gistId) {
      const response = await fetch(`https://api.github.com/gists/${gistId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `token ${settings.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          files: {
            [CLOUD_GIST_FILENAME]: {
              content: JSON.stringify(dataToSync, null, 2)
            }
          }
        })
      });
      
      if (!response.ok && response.status !== 404) {
        throw new Error(`Sync failed: ${response.statusText}`);
      }
      
      if (response.ok) {
        console.log('‚úì Auto-synced to cloud');
        return;
      }
    }
    
    // Create new gist if doesn't exist
    if (!gistId) {
      const response = await fetch('https://api.github.com/gists', {
        method: 'POST',
        headers: {
          'Authorization': `token ${settings.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          description: `Stock Portfolio MTF Tracker - Portfolio Data (Account: ${currentUser})`,
          public: false,
          files: {
            [CLOUD_GIST_FILENAME]: {
              content: JSON.stringify(dataToSync, null, 2)
            }
          }
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to create gist: ${response.statusText}`);
      }
      
      const gist = await response.json();
      gistId = gist.id;
      settings.gistId = gistId;
      saveCloudSettings(settings);
      console.log('‚úì Created new cloud sync gist:', gistId);
    }
  }

  async function syncFromCloudSilent() {
    const settings = getCloudSettings();
    if (!settings.token || !settings.gistId) return;
    
    const response = await fetch(`https://api.github.com/gists/${settings.gistId}`, {
      headers: {
        'Authorization': `token ${settings.token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        console.log('Cloud gist not found, using local data');
        return;
      }
      throw new Error(`Failed to fetch: ${response.statusText}`);
    }
    
    const gist = await response.json();
    const file = gist.files[CLOUD_GIST_FILENAME];
    
    if (!file) {
      console.log('No portfolio data in cloud gist');
      return;
    }
    
    const data = JSON.parse(file.content);
    
    if (!data.portfolio || !Array.isArray(data.portfolio)) {
      throw new Error('Invalid data format');
    }
    
    // Verify this data belongs to the current account
    if (data.account && data.account !== currentUser) {
      console.log(`Cloud data belongs to account "${data.account}", but current account is "${currentUser}". Skipping sync.`);
      return; // Don't sync data from a different account
    }
    
    // Check if cloud data is newer than local
    const localSaved = localStorage.getItem(`stockapp_portfolio_${currentUser}`);
    const localData = localSaved ? JSON.parse(localSaved) : [];
    const cloudTime = new Date(data.syncedAt || 0);
    const localTime = localData.length > 0 ? new Date(localData[0]?.lastModified || 0) : new Date(0);
    
    // Merge: prefer cloud if newer, otherwise merge both
    if (cloudTime > localTime || localData.length === 0) {
      // Use cloud data (it's newer or local is empty)
      portfolio = data.portfolio.map(stock => {
        const broker = stock.broker || 'POCKETFULL';
        const mtfFundsValue = Number(stock.mtfFunds || 0);
        const isMTF = typeof stock.isMTF === 'boolean' ? stock.isMTF : mtfFundsValue > 0;
        const computedRate = calculateBrokerDailyPercent(broker, mtfFundsValue);
        return {
          ...stock,
          broker,
          isMTF,
          interest: isMTF ? Number(stock.interest ?? computedRate) : 0,
          mtfFunds: isMTF ? mtfFundsValue : 0
        };
      });
      
      // Merge users data
      if (data.users) {
        const currentUsers = getUsers();
        const mergedUsers = { ...currentUsers, ...data.users };
        saveUsers(mergedUsers);
      }
      
      // Save merged data locally
      localStorage.setItem(`stockapp_portfolio_${currentUser}`, JSON.stringify(portfolio));
      console.log('‚úì Auto-synced from cloud:', portfolio.length, 'stocks');
    } else {
      // Local is newer, upload local to cloud
      console.log('Local data is newer, uploading to cloud...');
      await syncToCloudSilent();
    }
  }

  async function autoLoginRememberedUser() {
    const remembered = getRememberedUsers();
    let rememberedUser = localStorage.getItem(STORAGE_KEYS.REMEMBERED_LAST);
    if (!rememberedUser || !remembered[rememberedUser]) {
      rememberedUser = Object.keys(remembered)[0];
    }
    if (!rememberedUser) return false;
    const users = getUsers();
    const record = users[rememberedUser];
    if (!record) {
      setUserRemembered(rememberedUser, false);
      return false;
    }
    currentUser = rememberedUser;
    currentUserDisplayName = record.displayName || rememberedUser;
    localStorage.setItem(STORAGE_KEYS.CURRENT_USER, rememberedUser);
    localStorage.setItem(STORAGE_KEYS.CURRENT_USER_DISPLAY, currentUserDisplayName);
    // Load user data (will auto-sync from cloud if configured)
    await loadUserData();
    await showMainApp();
    return true;
  }

  // Auto-save every 30 seconds
  setInterval(() => {
    if (currentUser && portfolio.length > 0) {
      saveUserData();
      console.log('‚úì Portfolio auto-saved');
    }
  }, 30000);

  function formatCurrency(val) {
    return (val == null || val === "") ? "" : "‚Çπ" + Number(val).toLocaleString("en-IN", {minimumFractionDigits:2, maximumFractionDigits:2});
  }
  function formatPercent(val, digits = 2) {
    if (val == null || val === "" || isNaN(val)) return "0%";
    return Number(val).toFixed(digits) + "%";
  }
  function todayISO() {
    return (new Date()).toISOString().split("T")[0];
  }

  // INTERFACE
  document.getElementById('addForm').onsubmit = async function(e){
    e.preventDefault();
    const errorElem = document.getElementById('errorMsg');
    errorElem.innerText = "";
    errorElem.style.color = "var(--color-danger)";

    let symbol = document.getElementById('symbol').value.trim().toUpperCase();
    let company = document.getElementById('company').value.trim();
    const brokerId = brokerSelect ? brokerSelect.value : brokerCatalog[0].id;
    const brokerInfo = getBrokerInfo(brokerId);
    const isMTF = mtfEnabledToggle.checked;
    
    if (!symbol || !company) {
      errorElem.innerText = "‚ö†Ô∏è Please search and select a company first!";
      return;
    }
    let entryDate = document.getElementById('entryDate').value;
    let entryPrice = parseFloat(document.getElementById('entryPrice').value || 0);
    let quantity = parseInt(document.getElementById('quantity').value || 0);
    let ownCapital = parseFloat(document.getElementById('ownCapital').value || 0);
    let mtfFunds = isMTF ? parseFloat(document.getElementById('mtfFunds').value || 0) : 0;
    let interest = isMTF ? parseFloat(document.getElementById('interest').value || calculateBrokerDailyPercent(brokerId, mtfFunds)) : 0;
    let totalInvestment = entryPrice * quantity;
    
    // Comprehensive validation
    if (!symbol || !company || !entryDate || !entryPrice || !quantity || !ownCapital) {
      errorElem.innerText = "‚ö†Ô∏è Please fill all required fields.";
      return;
    }
    if (ownCapital < 0) {
      errorElem.innerText = "‚ö†Ô∏è Own capital must be positive!";
      return;
    }
    if (isMTF && mtfFunds < 0) {
      errorElem.innerText = "‚ö†Ô∏è MTF funds must be positive when MTF is enabled!";
      return;
    }
    if (entryPrice <= 0) {
      errorElem.innerText = "‚ö†Ô∏è Entry price must be greater than zero!";
      return;
    }
    if (quantity <= 0) {
      errorElem.innerText = "‚ö†Ô∏è Quantity must be at least 1!";
      return;
    }
    if (isMTF && ownCapital + mtfFunds < totalInvestment * 0.9) {
      errorElem.innerText = "‚ö†Ô∏è Warning: Own capital + MTF funds seems insufficient for total investment!";
    }
    
    // Show loading state
    errorElem.innerText = "‚è≥ Fetching live price for " + symbol + "...";
    errorElem.style.color = "var(--color-info)";
    
    // Fetch current price with error handling
    let currentPrice = null;
    try {
      currentPrice = await fetchNSEPrice(symbol.replace(".NS", ""));
    } catch (error) {
      errorElem.innerText = "‚ùå Error fetching price: " + error.message;
      errorElem.style.color = "var(--color-danger)";
      return;
    }
    
    if (currentPrice === null || currentPrice <= 0) {
      errorElem.innerText = `‚ùå Couldn't fetch live price for ${symbol}. Please verify the stock symbol is correct (e.g., RELIANCE, TCS, TATASTEEL). You can still add manually by entering a current price estimate.`;
      errorElem.style.color = "var(--color-danger)";
      
      // Offer to use entry price as fallback
      const useEntryPrice = confirm(`Price fetch failed for ${symbol}.\n\nWould you like to use entry price (‚Çπ${entryPrice}) as current price for now?\n\nYou can update it later when live prices work.`);
      if (!useEntryPrice) return;
      currentPrice = entryPrice;
      errorElem.innerText = "‚ö†Ô∏è Using entry price as current price (price fetch unavailable).";
      errorElem.style.color = "var(--color-warning)";
    } else {
      errorElem.innerText = "‚úì Live price fetched successfully: ‚Çπ" + currentPrice.toFixed(2);
      errorElem.style.color = "var(--color-success)";
    }
    let leverage = (ownCapital > 0) ? (totalInvestment / ownCapital) : 0;
    let daysHeld = Math.max(1, Math.ceil((new Date(todayISO()) - new Date(entryDate)) / 86400000));
    let currentValue = currentPrice * quantity;
    let totalPL = currentValue - totalInvestment;
    let plPc = (totalInvestment > 0) ? (100 * totalPL / totalInvestment) : 0;
    let totalInterest = (mtfFunds * interest * daysHeld) / 100;
    let netPL = totalPL - totalInterest;
    let netROI = (ownCapital > 0) ? (100 * netPL / ownCapital) : 0;
    let status = netPL > 0 ? "Profit" : (netPL < 0 ? "Loss" : "Neutral");

    portfolio.push({
      symbol, company, broker: brokerId, isMTF,
      entryDate, entryPrice, quantity, ownCapital, mtfFunds,
      totalInvestment, leverage, currentPrice, currentValue, totalPL, plPc, daysHeld,
      interest, totalInterest, netPL, netROI, status
    });
    saveUserData();
    await renderPortfolio();
    this.reset();
    if (brokerSelect) brokerSelect.value = brokerCatalog[0].id;
    if (mtfEnabledToggle) mtfEnabledToggle.checked = true;
    handleBrokerChange();
    applyMTFState();
    document.getElementById('entryDate').value = todayISO();
  }

  async function fetchAllPrices() {
    const errors = [];
    for (let stock of portfolio) {
      try {
        const price = await fetchNSEPrice(stock.symbol.replace(".NS", ""));
        if (price !== null && price > 0) {
          stock.currentPrice = price;
        } else {
          errors.push(stock.symbol);
          // Keep using last known price if fetch fails
          console.warn(`Using last known price for ${stock.symbol}`);
        }
      } catch (error) {
        errors.push(stock.symbol);
        console.error(`Error fetching ${stock.symbol}:`, error);
      }
      
      // Recalculate all metrics with error handling
      try {
        stock.currentValue = stock.currentPrice * stock.quantity;
        stock.totalPL = stock.currentValue - stock.totalInvestment;
        stock.plPc = stock.totalInvestment > 0 ? (100 * stock.totalPL / stock.totalInvestment) : 0;
        stock.daysHeld = Math.max(1, Math.ceil((new Date(todayISO()) - new Date(stock.entryDate)) / 86400000));
        stock.totalInterest = (stock.mtfFunds * stock.interest * stock.daysHeld) / 100;
        stock.netPL = stock.totalPL - stock.totalInterest;
        stock.netROI = stock.ownCapital > 0 ? (100 * stock.netPL / stock.ownCapital) : 0;
        stock.status = stock.netPL > 0 ? "Profit" : (stock.netPL < 0 ? "Loss" : "Neutral");
      } catch (calcError) {
        console.error(`Calculation error for ${stock.symbol}:`, calcError);
      }
    }
    
    if (errors.length > 0) {
      console.warn(`‚ö†Ô∏è Price fetch failed for: ${errors.join(', ')}`);
    }
  }

  async function renderPortfolio() {
    await fetchAllPrices();
    const tbody = document.getElementById('portfolioBody');
    tbody.innerHTML = "";
    for (let [i, stock] of portfolio.entries()) {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${stock.symbol}</td>
        <td>${stock.company}</td>
        <td>${getBrokerDisplayName(stock.broker)}</td>
        <td>${stock.entryDate}</td>
        <td>${formatCurrency(stock.entryPrice)}</td>
        <td>${stock.quantity}</td>
        <td>${formatCurrency(stock.ownCapital)}</td>
        <td>${formatCurrency(stock.mtfFunds)}</td>
        <td>${formatCurrency(stock.totalInvestment)}</td>
        <td>${stock.leverage.toFixed(2)}</td>
        <td>${formatCurrency(stock.currentPrice)}</td>
        <td>${formatCurrency(stock.currentValue)}</td>
        <td class="${stock.totalPL > 0 ? 'status-profit' : stock.totalPL < 0 ? 'status-loss' : 'status-neutral'}">${formatCurrency(stock.totalPL)}</td>
        <td>${stock.plPc.toFixed(2)}%</td>
        <td>${stock.daysHeld}</td>
        <td>${formatCurrency(stock.totalInterest)}</td>
        <td class="${stock.netPL > 0 ? 'status-profit' : stock.netPL < 0 ? 'status-loss' : 'status-neutral'}">${formatCurrency(stock.netPL)}</td>
        <td>${stock.netROI.toFixed(2)}%</td>
        <td>${stock.status}</td>
        <td><button class="delete-btn" title="Delete" onclick="deleteStock(${i})">‚úñ</button></td>
      `;
      tbody.appendChild(tr);
    }
    renderSummary();
    renderInsights();
  }

  function deleteStock(index) {
    portfolio.splice(index,1);
    saveUserData();
    renderPortfolio();
  }
  window.deleteStock = deleteStock;

  function renderSummary() {
    const wrap = document.getElementById('summaryWrap');
    if (portfolio.length === 0) { wrap.innerHTML = ""; return; }
    const totalOwn = portfolio.reduce((a,s)=>a+Number(s.ownCapital),0);
    const totalMTF = portfolio.reduce((a,s)=>a+Number(s.mtfFunds),0);
    const totalInv = portfolio.reduce((a,s)=>a+Number(s.totalInvestment),0);
    const curVal = portfolio.reduce((a,s)=>a+Number(s.currentValue),0);
    const grossPL = portfolio.reduce((a,s)=>a+Number(s.totalPL),0);
    const netPL = portfolio.reduce((a,s)=>a+Number(s.netPL),0);
    const totalInt = portfolio.reduce((a,s)=>a+Number(s.totalInterest),0);
    const netROI = totalOwn > 0 ? (100*netPL/totalOwn) : 0;
    const mtfUtilization = 1000000; // Example MTF limit, update as needed
    wrap.innerHTML = `
      <div class="summary-card" title="Actual funds deployed">
        <div class="summary-title">Own Capital Invested</div>
        <div class="summary-value">${formatCurrency(totalOwn)}</div>
      </div>
      <div class="summary-card" title="MTF borrowed">
        <div class="summary-title">MTF Borrowed</div>
        <div class="summary-value">${formatCurrency(totalMTF)}</div>
      </div>
      <div class="summary-card" title="Total net gain/loss after interest">
        <div class="summary-title">Net P/L</div>
        <div class="summary-value" style="color:${netPL>0?"var(--color-success)":netPL<0?"var(--color-danger)":"var(--color-warning)"}">${formatCurrency(netPL)}</div>
        <div class="summary-detail">Net ROI: ${netROI.toFixed(2)}%</div>
      </div>
      <div class="summary-card" title="Current market value">
        <div class="summary-title">Portfolio Value</div>
        <div class="summary-value">${formatCurrency(curVal)}</div>
        <div class="summary-detail">Gross P/L: ${formatCurrency(grossPL)}</div>
      </div>
      <div class="summary-card" title="MTF used / available">
        <div class="summary-title">MTF Utilized</div>
        <div class="summary-value">${(100*totalMTF/mtfUtilization).toFixed(1)}%</div>
        <div class="summary-detail">Limit: ‚Çπ10,00,000</div>
      </div>
      <div class="summary-card" title="Sum of interest paid on MTF">
        <div class="summary-title">Interest Paid</div>
        <div class="summary-value">${formatCurrency(totalInt)}</div>
        <div class="summary-detail">Annualize: ${(totalInt*360/Math.max(1,portfolio[0]?.daysHeld||1)).toFixed(0)}/stock</div>
      </div>
    `;
  }

  function renderInsights() {
    const wrap = document.getElementById('insightsWrap');
    if (!wrap) return;
    if (portfolio.length === 0) { wrap.innerHTML = ""; return; }

    const sortedByNet = [...portfolio].sort((a, b) => b.netPL - a.netPL);
    const topPerformer = sortedByNet[0];
    const bottomPerformer = sortedByNet[sortedByNet.length - 1];
    const highestLeverage = [...portfolio].sort((a, b) => b.leverage - a.leverage)[0];
    const brokerTotals = portfolio.reduce((acc, stock) => {
      acc[stock.broker] = (acc[stock.broker] || 0) + Number(stock.mtfFunds || 0);
      return acc;
    }, {});
    const brokerLeaders = Object.entries(brokerTotals).sort((a, b) => b[1] - a[1]);
    const mtfStocks = portfolio.filter(stock => stock.isMTF && (stock.mtfFunds || 0) > 0);
    const avgInterest = mtfStocks.length ? mtfStocks.reduce((sum, stock) => sum + Number(stock.interest || 0), 0) / mtfStocks.length : 0;
    const avgDaysHeld = portfolio.reduce((sum, stock) => sum + Number(stock.daysHeld || 0), 0) / portfolio.length;
    const mtfVsOwn = (() => {
      const own = portfolio.reduce((sum, stock) => sum + Number(stock.ownCapital || 0), 0);
      const mtf = portfolio.reduce((sum, stock) => sum + Number(stock.mtfFunds || 0), 0);
      const total = own + mtf || 1;
      return { ratio: (mtf / total) * 100, own, mtf };
    })();

    wrap.innerHTML = `
      <div class="insight-card">
        <div class="insight-title">Top Performer</div>
        <div class="insight-value">${topPerformer ? topPerformer.symbol : '‚Äî'}</div>
        <div class="insight-meta">${topPerformer ? formatCurrency(topPerformer.netPL) + ' ‚Ä¢ ' + formatPercent(topPerformer.netROI) : 'Add a stock to see insights'}</div>
      </div>
      <div class="insight-card">
        <div class="insight-title">Under Watch</div>
        <div class="insight-value">${bottomPerformer ? bottomPerformer.symbol : '‚Äî'}</div>
        <div class="insight-meta">${bottomPerformer ? formatCurrency(bottomPerformer.netPL) + ' ‚Ä¢ ' + formatPercent(bottomPerformer.netROI) : 'No data yet'}</div>
      </div>
      <div class="insight-card">
        <div class="insight-title">Highest Leverage</div>
        <div class="insight-value">${highestLeverage ? highestLeverage.symbol : '‚Äî'}</div>
        <div class="insight-meta">${highestLeverage ? highestLeverage.leverage.toFixed(2) + 'x leverage' : 'Add leveraged trades'}</div>
      </div>
      <div class="insight-card">
        <div class="insight-title">MTF Mix</div>
        <div class="insight-value">${formatPercent(mtfVsOwn.ratio, 1)}</div>
        <div class="insight-meta">MTF ‚Çπ${mtfVsOwn.mtf.toLocaleString('en-IN')} / Own ‚Çπ${mtfVsOwn.own.toLocaleString('en-IN')}</div>
      </div>
      <div class="insight-card">
        <div class="insight-title">Top Broker Usage</div>
        <div class="insight-value">${brokerLeaders.length ? getBrokerDisplayName(brokerLeaders[0][0]) : '‚Äî'}</div>
        <div class="insight-meta">${brokerLeaders.length ? formatCurrency(brokerLeaders[0][1]) + ' borrowed' : 'No MTF exposure'}</div>
      </div>
      <div class="insight-card">
        <div class="insight-title">Avg Interest ‚Ä¢ Holding</div>
        <div class="insight-value">${mtfStocks.length ? formatPercent(avgInterest) : '0%'}</div>
        <div class="insight-meta">Avg holding ${avgDaysHeld.toFixed(1)} days</div>
      </div>
    `;
  }

  function renderCharts() {
    if (typeof Chart === 'undefined') return;
    const allocationCtx = document.getElementById('chartAllocation');
    const profitCtx = document.getElementById('chartProfit');
    const brokerCtx = document.getElementById('chartBroker');
    if (!allocationCtx || !profitCtx || !brokerCtx) return;

    const destroyChart = (key) => {
      if (chartRefs[key]) {
        chartRefs[key].destroy();
        chartRefs[key] = null;
      }
    };

    if (!portfolio.length) {
      Object.keys(chartRefs).forEach(destroyChart);
      ['chartAllocation', 'chartProfit', 'chartBroker'].forEach(id => {
        const canvas = document.getElementById(id);
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
      });
      return;
    }

    const palette = [
      '#667eea', '#764ba2', '#ed8936', '#48bb78', '#e53e3e',
      '#38b2ac', '#805ad5', '#f56565', '#4299e1', '#d53f8c'
    ];
    const colorAt = (idx) => palette[idx % palette.length];

    destroyChart('allocation');
    chartRefs.allocation = new Chart(allocationCtx, {
      type: 'doughnut',
      data: {
        labels: portfolio.map(stock => stock.symbol),
        datasets: [{
          data: portfolio.map(stock => Number(stock.currentValue || 0)),
          backgroundColor: portfolio.map((_, idx) => colorAt(idx)),
          borderWidth: 1
        }]
      },
      options: {
        plugins: {
          legend: { position: 'bottom' }
        }
      }
    });

    destroyChart('profit');
    chartRefs.profit = new Chart(profitCtx, {
      type: 'bar',
      data: {
        labels: portfolio.map(stock => stock.symbol),
        datasets: [{
          label: 'Net P/L (‚Çπ)',
          data: portfolio.map(stock => Number(stock.netPL || 0)),
          backgroundColor: portfolio.map(stock => stock.netPL >= 0 ? 'rgba(72,187,120,0.6)' : 'rgba(245,101,101,0.6)'),
          borderColor: portfolio.map(stock => stock.netPL >= 0 ? 'rgba(72,187,120,1)' : 'rgba(245,101,101,1)'),
          borderWidth: 1
        }]
      },
      options: {
        plugins: { legend: { display: false } },
        scales: {
          y: {
            ticks: {
              callback: value => `‚Çπ${Number(value).toLocaleString('en-IN')}`
            }
          }
        }
      }
    });

    const brokerAggregation = portfolio.reduce((acc, stock) => {
      const key = stock.broker || 'POCKETFULL';
      acc[key] = (acc[key] || 0) + Number(stock.mtfFunds || 0);
      return acc;
    }, {});
    const brokerEntries = Object.entries(brokerAggregation).filter(([, value]) => value > 0);
    const brokerLabels = brokerEntries.length ? brokerEntries.map(([key]) => getBrokerDisplayName(key)) : ['No MTF usage'];
    const brokerValues = brokerEntries.length ? brokerEntries.map(([, value]) => value) : [1];

    destroyChart('broker');
    chartRefs.broker = new Chart(brokerCtx, {
      type: 'polarArea',
      data: {
        labels: brokerLabels,
        datasets: [{
          data: brokerValues,
          backgroundColor: brokerLabels.map((_, idx) => colorAt(idx)),
          borderWidth: 1
        }]
      },
      options: {
        plugins: { legend: { position: 'bottom' } },
        scales: {
          r: {
            ticks: { callback: value => `‚Çπ${Number(value).toLocaleString('en-IN')}` }
          }
        }
      }
    });
  }

  // On load: Token-based authentication check (stateless, multi-device support)
  window.addEventListener('DOMContentLoaded', async function() {
    populateBrokerOptions();
    handleBrokerChange();
    applyMTFState();
    updateInterestFromInputs();
    
    // Check for valid tokens first (stateless authentication)
    const authenticated = await isAuthenticated();
    
    if (authenticated) {
      // User has valid tokens - authenticate automatically
      const userInfo = await getCurrentUserFromToken();
      if (userInfo) {
        currentUser = userInfo.userId;
        currentUserDisplayName = userInfo.username;
        localStorage.setItem(STORAGE_KEYS.CURRENT_USER, currentUser);
        localStorage.setItem(STORAGE_KEYS.CURRENT_USER_DISPLAY, currentUserDisplayName);
        // Load user data (will auto-sync from cloud if configured)
        await loadUserData();
        await showMainApp();
      } else {
        // Token invalid, show login
        showLoginForm();
      }
    } else {
      // No valid tokens - check for remembered user (backward compatibility)
      const savedUser = localStorage.getItem(STORAGE_KEYS.CURRENT_USER);
      const savedDisplay = localStorage.getItem(STORAGE_KEYS.CURRENT_USER_DISPLAY);
      if (savedUser) {
        currentUser = savedUser;
        currentUserDisplayName = savedDisplay || savedUser;
        // Load user data (will auto-sync from cloud if configured)
        loadUserData().then(() => showMainApp());
      } else {
        autoLoginRememberedUser().then(logged => {
          if (!logged) {
            showLoginForm();
          }
        });
      }
    }
    document.getElementById('entryDate').value = todayISO();
  });

  // Auto-refresh every 2 min to simulate live prices (can be user-adjusted)
  setInterval(()=>{
    if(portfolio.length>0){renderPortfolio();}
  },120000);
</script>
</body>
</html>
